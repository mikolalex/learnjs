### Вивчи Javascript - заради добра, заради України!

@@@
Javascript - це приємна і красива мова програмування, яка стає дедалі більш популярною по всьому світу.
Якщо ви ніколи не займались програмуванням, то Javascript цілком підійде в якості першої мови.
В Україні для вивчення Javascript є ще кілька вагомих підстав: ставши успішним JS-програмістом, ви не тільки покращите свій фінансовий стан, отримаєте цікаву роботу, а і 
допоможете нашій державі! Працюючи з іноземними замовниками, ви зміцнюєте нашу валюту, піднімаєте ВВП, покращуєте міжнародний імідж України!
Отже, перефразовуючи Ільфа і Петрова, "Старанно вивчаючи джаваскрипт, ти допомагаєш суспільству!" (і собі :)

Цей підручник написаний в першу чергу для людей, які не мали раніше досвіду програмування, але знайомі із HTML. Я постарався максимально детально описати базові 
поняття джаваскрипта, так щоб це було зрозуміло всім. Адже, якщо ви ніколи не мали справи з програмуванням, то навіть будь ви суперрозумник із височенним IQ, все одно багато моментів для вас будуть незрозумілими.
Якщо ж ви, читаючи цей підручник, відчуватимете, що автор розсусолює, занадто детально поясню елементарні речі - що ж, вітаю, можете потішитись, ви розумна людина і ваш мозок сприймає все нове швидше, аніж у інших людей!

У підручнику я стараюсь пояснювати теорію і одразу підкріплювати її практикою. Але мушу попередити усіх, хто рветься одразу в бій: перші ніж ви зможете робити більш-менш серйозні практичні завдання, вам треба буде виконати багато 
примітивних, "штучних" прикладів. 
Так що запасіться терпінням, і будьте готові вирішувати задачі типу "У Петрика 2 шоколадки, а у Марійки одна, скільки у них шоколадок разом?", тільки в контексті програмування.
Якщо ви, наприклад, власник інтернет-магазину, і хочете навчитись, як доробити якийсь вордпрес-модуль, щоб він працював, так як вам хочеться - вам цей підручник навряд чи допоможе.
Тобто, він вам допоможе, тільки якщо ви ретельно прочитаєте його від початку до кінця, а шукати якихось конкретних рецептів тут не треба.
Підручник розбитий на кілька розділів, які будуть додаватись по мірі написання, кожен розділ містить теорію, приклади коду, завдання.
Також ви можете писати свої коментарі і питання по матеріалу, а автор і інші користувачі зможуть вам відповісти.

Отже, вирушаємо!
<div style="margin-top:100px;"></div>
<img src="vt.jpg">
@@@
@@@
##Зміст



<ul id="zmist">
</ul>

@@@
@@@
##Що таке Javascript і чим він пахне


Я не буду тут вам переказувати історію винекнення Javascripta, у цьому нема сенсу, перейдемо до суті.
З самого початку Javascript задумувався як мова, як допоможе зробити веб-сторінки інтерактивними.
(нагадую, що читання цього підручника має сенс тільки для тих, хто більш-менш знайомий з основами HTML).
Але як це часто буває з веб-технологіями, автори задумували одне, а вийшло щось інше. Javascript давно переріс рамки "мови простеньких скриптиків",
на ньому тепер пишуться дуже великі і складні програми, апплікейшни, ну от хоча б Gmail(можливо, він вам не здається складним, але повірте - досить і досить серйозний застосунок).
За допомогою джаваскрипта простенькі ХТМЛ сторінки по типу "Це моя домашня сторінка, ось моє фото, а ось мій кіт" переросли у серйозні інтерактивні застосунки.
Однак джаваскрипт виявився настільки кльовою мовою, що її, трошки підлампичивши, адаптували і для зовсім інших задач, не пов"язаних з вебом(NodeJS, який працює на сервері, і інші технології).
Так що, повторюсь, якщо ви ще сумніваєтесь - джаваскрипт це дуже цікава технологія, яка застосовується у багатьох різноманітних сферах, але перш за все - у вебі, і її, без сумніву, варто вивчати.

У нашому підручнику ми сконцентруємось на традиційній формі джаваскрипта. Мова іде про джаваскрипт у браузері, де його задача - маніпулювати ХТМЛ сторінкою.
У цій сфері джаваскрипт є повним монополістом. Річ у тім, що кожна мова програмування потребує програму, яка б її інтерпретувала.
Наприклад, ХТМЛ - це просто набір символів, текст, і тільки у браузері він перетворюється на барвисту веб-сторінку. Чому? Бо кожен браузер "вміє" інтерпретовувати ХТМЛ, себто, робити із гів... із текста картинку.
Так ось, єдиною мовою програмування, яку також можуть інтерпретовувати усі браузери, є Джаваскрипт. Так склалось.
Це значить, якщо ви хочете додати інтерактивності свої веб-сторінці, ви можете зробити це тільки із допомогою джаваскрипта.

Отже, які задачі вирішує джаваскрипт? Ви знайомі із ХТМЛ, який теж, в принципі, є мовою програмування. Однак, який би прекрасний не був ХТМЛ і його супутник ЦСС, вони обмежені у своїх можливостях - вони статичні.
Припустимо, ви верстаєте меню, і хочете, щоб кожна його кнопка при наведенні змінювала колір. Без проблем, за допомогою CSS :hover ви можете це зробити.
А як зробити, щоб ця кнопка змінила свій колір ЛИШЕ ОДИН РАЗ? На жаль, ХТМЛу і ЦССу ця задача не до снаги.
Натомість, це може зробити джаваскрипт. Як це робиться - пояснюю "на пальцях".
У джаваскрипті ми можемо писати "хендлери" - це певні набори дій, які відбуваються у разі, якщо юзер зробить певну дію.
Наприклад, "якщо юзер клікнув по кнопці... сховати її". У нашому випадку, нам треба, щоб коли юзер кліка по кнопці, 
ми перевіряли: чи клікав він по ній до цього. Якщо вже клікав хоча б раз, то нічого не робимо. Якщо ще не клікав, то змінити колір.
Наш уявний код виглядав би так:
```
КОЛИ юзер клікає по кнопці
	1. Подивитись, чи не клікав він по ній до цього
	2. Якщо ще ні разу не клікав, змінити її колір
	3. Якщо вже клікав, не робити нічого
```
Для порівняння, ось код на справжньому джаваскрипті, який реалізовує цю задачу:
```


var button_clicked = false;
$("button").click(function(){
	if(!button_clicked){
		$(this).css('color', 'red');
		button_clicked = true;
	} 
	else {
		// do nothing!
	}
})
```

Страшно? Сподіваюсь, що ні, а якщо і так, то не бійтеся, ми дуже скоро розберемо цей код і він вам здасться очевидним і простим, не страшніше ніж строчка "ИТОГО" в інвентарній книзі(в дитинстві, коли я не знав значення цього слова, воно мене лякало своєю неминучістю і загадкосвістю).

Отже, ще раз з"ясуємо основні моменти. Джаваскрипт - це аж ніяк не конкурент ХТМЛу і ЦССу, а скоріше доповнення. Він має зовсім відмінний від них принцип дії.
В той час, як ЦСС і ХТМЛ є декларативними мовами, в яких ми пишемо "ЩО МИ ХОТІЛИ Б БАЧИТИ"(дів там або ул), то джаваскрипт є імперативною мовою, в якій ми пишемо, "ЩО І ЯК РОБИТИ".

Джаваскрипт можна вставити на сторінку дуже просто - за допомогою тега &ltscript&gt;
```
<div class="something"></div>
<script>
	document.getElementsByClassName('something')[0].innerHTML = 'Hello, world!';
</script>
```

Ось так виглядає шматочок джс-тексту, вбудованого у ХТМЛ сторінку. 
Все, що лежить усередині тегу script, не буде показане на сторінці, натомість, воно буде ВИКОНАНЕ браузером.
В даному випадку, цей код означає таке: "пошукати на сторінці теги із класом "something", вибрати перший з них, і всередину нього запхати текст "Hello, world!"
Кожного разу, при завантаженні сторінки, цей код буде виконаний один раз.
Для виконання наших завдань ви можете узяти будь-яку ХТМЛ сторінку, вставити туди тег script, і писати у ньому код. Після кожної можифікації коду потрібно заново відкрити сторінку(оновити її).
@@@
@@@
## Початок знайомства з Javascript. Змінні



Увесь Джаваскрипт, по суті, складається з двох речей: із змінних і функцій. Змінні зберігають у собі дані, а функції їх обробляють, модифіковують і щось роблять.
Все, більше нічого у джаваскрипті нема. Для початку розберемось із змінними.
```
var name = 'John'; // я змінна!
var surname = 'Petrenko';
var age = 42;
```
name, surname, age - це змінні!
У першої змінної |ім"я| - name, а |значення| - John.
У перших двох змінних значення - це слова, а у третьої змінної - число.
Ось які важливі правила ви можете дізнатись із цього прикладу:<ul>
	<li>
		кожна дія в джаваскрипт пишеться з нової строчки
	</li>
	<li>
		після кожної дії ми повинні ставити крапку з комою(але є винятки)
	</li>
	<li>
		коли ми вперше використовуємо змінну, ми повинні писати ключове слово |var|(від англійського |variable| - змінна)
	</li>
	<li>
		Якщо ми хочемо записати у змінну слово або кілька слів - ми беремо їх у лапки. Числа у лапки можна не брати.
	</li>
	</ul>
Приклади для запам"ятовування:
	^
var 12_friends_of_ocean = 'movie'; // назва змінної НЕ МОЖЕ починатись із ЦИФРИ!
var i_am_a_c**l_hac|-|er = 'Valyera'; // Не вживайте ніяких спецсимволів у назві змінної! 
//Тільки букви, цифри і нижнє підкреслювання!
var good_intentions = evil; // слова беруться в лапки!
var multiline = 'In faith, I do not love thee with mine eyes,
For they in thee a thousand errors note; ';
// строчка не може містити переноси каретки!
^
var my_current_job_52 = 'JS developer'; // цифри можуть стояти будь-де, тільки не на початку
var my_first_job = 'tractor driver';
var a1 = "42";// ми можемо брати числа у лапки, якщо хочеться
var x2 = 37.5; // а можемо і не брати! Краще НЕ брати
var multiline = 'In faith, I do not love thee with mine eyes,' + 
'For they in thee a thousand errors note; ';
// для того, щоб записати текст у кілька строчок, 
// використовуйте об"єднання строчок за допомогою оператора +
	^





Отже, ми навчились присвоювати змінним значення. Що робити далі?
Найпростіше - це просто вивести значення змінної. При чому, вивести не в документ(роботу із ХТМЛ ми розглянемо пізніше), а просто в консоль.
Консоль необхідна програмісту для відлагоджування програми, в неї можна щось виводити, що не зачепить сам ХТМЛ документ, але допоможе нам зрозуміти, що відбувається у нас в коді.
У вашій панелі відлагоджування відкрийте вкладку "Console", там буде чистий лист. Спробуйте виконати у себе в документі(в тезі script, ви ж пам"ятаєте?) наступний код:

```
var answer = 42;
console.log(answer);
```
Ви побачите, що у вашій консолі вивелось значення змінної "answer" - 42.
В подальшому, якщо я казатиму "подивіться значення змінної", це означатиме - виведіть її в консоль.

```
var a = 42 * 3; // 126
```
Подвійні рисочки означають коментар! Часто ми писатимемо те значення, яке буде у змінної, в коментарі, якщо воно не очевидне.

@@@
@@@
## Операції зі змінними

Отже, поки що ми вміємо присвоювати змінним якесь значення, і виводити його в консоль.
А що ж ми можемо зробити зі змінними більш толкового?
З числами ми можемо робити арифметичні операції:

```
var length = 10;
var height = 3;

var area = length * height;// 30

// Ми можемо множити їх, ділити і віднімати!
var x = length - 20; // -10
// Для комплексних підрахунків, використовуйте дужки, так само, як і в математиці!
var a = ((length - height + 1)/2)*10; // 40
//спочатку віднімемо, потім додамо, потім поділимо, потім помножимо
```

Ок, це добре, а як бути зі словами?

```

var name = 'Ivan';
var surname = 'Kychatyi';

var fullname = name + surname;
```

2 + 12 буде 14, а скільки ж буде Ivan + Kychatui? Правильно, IvanKychatui!
Тобто, змінні, які містять слова, при додаванні - просто "склеюються разом"!
Це дуже зручно і часто використовується, наприклад, при генеруванні ХТМЛу(так, джаваскрипт таким займається!)
У нашому прикладі, щоб повне ім"я виглядало гарно, йому не вистачає якогось префіксу, а також пробілу між іменем і прізвищем.
Спробуємо додати його. Просто потрібно "склеїти" разом змінні і інші "слова".

```

var fullname = 'Mr. ' + name + ' ' + surname; // 'Mr. Ivan Kychatui'
```
Слова у джаваскрипті прийнято називати строчками.
Будь-який набір символів, окрім числа - це строчка.
Наприклад, 'wgfwe98yug8 t345345 124214124' - це строчка, "Peter's pecker picked another pickle bearing pussy pepper" - це теж строчка!
Строчки |обов"язково| беруться в лапки.

Ось ви і зрозуміли, чому потрібно відрізняти числа від слів.
Подивіться наступний ключовий приклад:

```
var Ivan_has_apples = 3;
var Mary_has_apples = 5;
var total_number_of_apples = Ivan_has_apples + Mary_has_apples; // 8

// а якщо ви спробуєте скласти строчки як числа
var Ivan_has_apples = '3';
var Mary_has_apples = '5';
var total_number_of_apples = Ivan_has_apples + Mary_has_apples; // 35!

// яблук насправді дещо менше
```
А все тому, що у другому випадку ви спробували скласти СТРОЧКУ 3 зі СТРОЧКОЮ 5, на що справедливо отримали результат - 35!


Так що поки що запам"ятайте, що змінні бувають двох типів: строчки і числа, і змішувати їх не варто(або робити це обережно)

Як ви помітили, інколи в змінну записується результат роботи над іншою змінною. А чи буде працювати така конструкція?

```

var a = 35;

a = a + 10;
```
Тут є кілька коментів, що можуть викликати ваш подив. 
По-перше, чому я в другій строчці не написав var? Тому що, коли ми згадуємо змінну удруге(і всі подальші рази), писати var не треба!
Добре, а як же ми так беремо... і записуємо в змінну а саму себе? Хіба це можливо?

Звісно, якщо розглядати цей запис з точки зору математики, це нонсенс. Рівняння виду x = x + 1 не має коренів, адже немає такого числа, яке було б рівне самому собі плюс одиниця)
Але це не математика. Цей вираз потрібно читати так:
"Запишіть будь-ласка у змінну "а" її поточне значення, до якого додали десять"
Отже, коли ми у правій частині пишемо якийсь вираз, вираховуєтсья його значення, а потім воно записується у ліву частину!


Ви можете спитати, а що ж відбувається із попереднім значенням? Відповідаю: воно зникає.
Ми записуємо "поверх" існуючого значення. Це може здатись дивним з точки зору побуту, т.к., до прикладу, ви не можете налити у банку з водою молока, перш ніж ви не виллєте звідти воду.
Однак у світі інформатики все дещо простіше. Розглянемо такий приклад

```
var my_beloved = 'Oksana';

// багато води утекло з тих пір...
my_beloved = 'Iryna';

// раптово!
```
Час проходить, і деякі речі змінюються. Звісно, реальна Оксана нікуди не ділася, просто місце у вашій душі, яке було зайняте нею, тепер займає інша дівчина.
Так і зі змінними: нове значення заміщує старе, і старе просто припиняє існувати, що, однак, не значить, що об"єкт, який воно означало, теж зник.

Одне дуже важливе правило: змінні можна використовувати тільки |після| того, як ви їх оголосили.

^
// синтаксична помилка, ви не взяли строчку в лапки
var a = Mike;

// ще одна помилка, ви використовуєте різні типи лапок в одній строчці
var b = 'I feel good!";

// 'типова помилка: лапки всередині строчки сприймаються як її завершення!
// Такий запис призведе до помилки! Джаваскрипт подумає, що строчка - це "Hi, what", 
// (ви ж обмежили її одинарними лапками), а далі іде вже... незрозуміло що!
var q = 'Hi, what's going on?';

//'ви пробуєте використати змінну |y| |до| її оголошення! Це призведе до помилки
var x = 10;
var sum = x + y;
var y = 13;

^

// строчки пишуться тільки в лапках!
var a = 'Mike';

// одинарних або подвійних!
var b = "Josh";

// якщо в самій строчці використовуються одинарні лапки, обгорніть її в подвійні, і навпаки!
var q = "Hi, what's going on?";

^
Окрім простого додавання, у джаваскрипті є також окрема операція, яка збільшує число на одиницю(називається інкремент).
```
var a = 35;
++a;
console.log(a); //36
console.log(++a); //37
```
Поки що вам не ясно, для чого знадобився короткий запис для такої операції, але потім побачите, що він нам часом дуже спростить життя.


Завдання для засвоєння.
Починаємо ліпити пасочки.

```
var a = 23;
var b = 44;

// Напишіть таку змінну "c", яка була б подвоєною сумою змінних "a" i "b"

???%c == 134%
```
Це пробний приклад. Щоб отримати правильну відповідь, введіть "var c = (a + b)*2;" і натисніть "Перевірити!"

А ось ще завдання

```
var name = 'John';
var surname = 'Doe';

// Створіть змінну fullname, яка б була результатом складення 
// змінної name, пробіла і змінної surname, тобто, 'John Doe'

???%fullname == "John Doe"%var fullname = name + ' ' + surname;%
```
```
// "Загорніть" текст змінної в тег div
var str = "Johnny got his gun"; 

// var wrapped = ???; 

???%wrapped == '<div>Johnny got his gun</div>'%var wrapped = '<div>' + str + '</div>'%

// console.log(wrapped); // <div>Johnny got his gun</div>
```

```
// нехай змінна tag є тегом, в який треба загорнути строчку, а str - сама строчка.
var tag = 'b';

var str = 'Hello, Dolly!';

???%wrapped == '<b>Hello, Dolly!</b>'%var wrapped = '<' + tag + '>' + str + '</' + tag + '>'%

console.log(wrapped); // <b>Hello, Dolly!</b>
```
Вітаю, ви дещо знаєте про змінні! :)

@@@

@@@

## Функції

Це сама сіль джаваскрипта. Якщо змінні потрібні для того, щоб зберігати дані, то функції покликані |щось із ними робити|.
Вони бувають двох типів: стандартні, які входять у базовий джентльменський набір можливостей джаваскрипта, і самописні, які ви створюєте самі для вирішення своїх потреб.

# Стандартні функції

Стандартні функції джаваскрипта дозволяють нам зробити ті речі, які ми самі нізащо не змогли б зробити, використовуючи лише змінні і відомі нам операції над ними.
Наприклад, вивести юзеру в браузер повідомлення про щось. 
```
var user = 'Sasha';
var greeting = 'Hello, Mr. ' + Sasha;

alert(greeting);  // <-ось це функція!

```
Тут alert(...) - це |виклик| функції. Кожна функція може викликатись будь-яку кількість разів, в будь-якому місці.
Те, що знаходиться в дужках - це |аргументи| функції. Функція alert() виводить якесь повідомлення на екран. Але ж ми повинні вказати, яке!
Ось для цього існують аргументи функції. Аргументи - це якісь дані, частіше за все змінні, які ми |передаємо| в функцію при її виклику.
Як бачите, кожна функція має ім"я, по якому її можна викликати.
Для того, щоб викликати функцію, треба написати її ім"я, відкрити дужки, написати там її аргументи, і закрити дужки :)

^
// змінна ololo не існує(ми її не оголосили)
alert(ololo); 

alert(msg);
var msg = 'Hello, long distance runner!';
// теж неправильно, змінна повинна бути оголошена |ДО| того, як її використають(вище)

// ми не передали жодного аргументу, це не є добре)
alert();

^

var ololo = 'Iona';
alert(ololo);

// так теж можна - передавати в якості аргументів строчки!
alert('Hello, Dolly!');

// і навіть комбінувати строчки зі змінними прямо в аргументах функції!
var name = 'Mike';
alert('Hello, ' + name + '!');

^

Однак, є і інший різновид стандартних функцій, які викликаються дещо інакше.

# Методи

```

var a = 'Hello, my name is John!';

var b = a.replace("John", 'Petro'); // 'Hello, my name is Petro!'

```

Такі фунції викликаються якби "від змінної". Ви пишете ім"я змінної, ставите крапку, і далі пишете ту функцію, яку хотіли б до неї застосувати!

```
var a = 'I am A CaMeL';

a = a.toLowerCase();// 'i am a camel'

```

Давайте тепер роздивимось, що це за функції і як з ними поводитись.
Вище були згадані дві функції, replace() і toLowerCase(). Перша функція, як ви здогадались, замінює в строчці задані слова іншими.
Друга функція робить усі букви у строчці - прописними, тобто, у нижньому регістрі.

Ці функції відносяться до групи т.зв. строкових функцій, тобто функцій, які призначені для роботи зі строчками.
Вони викликаються "від змінної", тобто, через крапку після імені змінної.
Функція replace() має два аргументи - перший означає "шо шукати", а другий - "на що замінити знайдені строчки".

Функція toLowerCase() не має аргументів взагалі. Ви можете спитати, а як вона дізнається, з якою строчкою їй працювати?
Справа в тому, що передавати вихідну строчку немає потреби, так як нею є та строчка, "від якої" ми викликаємо функцію.
В даному випадку, змінна "а". У цьому і весь сенс виклику "від змінної": він якби по замовчуванню використовує ту змінну, від якої ми виликаємо.
Такі функції у джаваскрипті називаються |"методами"|(це важливий термін, запам"ятайте його).

^
// безглуздий запис - ми викликаємо функцію, але нікуди не записуємо результат! 
// Змінна str залишиться такою ж
var str = 'Donatas Banionis';
str.replace("s", "");
console.log(str); // 'Donatas Banionis', те саме

^

var str = 'Donatas Banionis';
str = str.replace("s", "");
console.log(str);// 'Donata Banionis'

^ 
Ми замінили літеру "s" на пусту строчку, тобто, фактично - вирізали її. Зверніть увагу, метод replace() замінює лише перше входження шуканої строчки!
Виклик методу не впливає на ту змінну, від якої ми його викликали.
Для того, щоб змінити значення змінної, його треба в неї записати.

```

var fruits = 'bananas, apples, carrots';

// carrots?!
var real_fruits = fruits.replace("carrot", "apricot");

console.log(real_fruits); // 'bananas, apples, apricots'
console.log(fruits); // 'bananas, apples, carrots' - без змін, як і очікувалось!

```
Джаваскрипт має багато стандартних функцій і методів для роботи зі строчками і числами, повний перелік ви можете знайти в інтернеті)
Ми будемо поступово знайомитися із деякими з них.


# Самописні функції

Нарешті, ви можете створювати функції самі!
Це відбувається у два етапи: 

а) ви описуєте функцію

б) користуєтесь нею!

При чому, другий етап вам вже відомий - самописними функціями користуються так само, як і стандартними.
А от як описати функцію?
Для цього є певний синтаксис. Коли ви зустрічаєте слово "синтаксис" в цьому підручнику, це означає, що зараз буде приклад, в якому треба звертати увагу
на найменші дрібниці і нюанси, і свято дотримуватись їх, інакше ваш код не запрацює.
Вам вже відомий синтаксис оголошення змінних(слово var), синтаксис операцій(знак дорівнює і крапка з комою в кінці), і ви вже знаєте, як викликати функції(написати ім"я функції і в дужках аргументи).

Тепер ви повинні запам"ятати синтаксис |оголошення| функції.

```

var get_square = function(num){
	return num * num;
}

// функція get_square буде повертати квадрат числа, тобто, число, помножене само на себе
var a = 3;
var b = get_square(a); // 9

// ще приклад
// функція повертає строчку, загорнуту в заданий тег.
var wrap_in_tag = function(str, tagname){
	var wrapped = '<' + tagname + '>' + str + '</' + tagname + '>';
	return wrapped;
}

var a = 'span';
var g = 'Hello, I love you, could you tell me your name';

var html = wrap_in_tag(g, a);

html; // <span>Hello, I love you, could you tell me your name</span>

```

Тут уже є багато над чим помедитувати.
Для початку, розберемось із синтаксисом, тобто, як треба правильно розставляти фігурні дужки і коми, щоб у вас усе працювало.

По-перше, зверніть увагу, що оголошення функції подібне до створення змінної - ліва частина у них однакова.
Ми пишемо ключове слово "var" і назву функції, яку ми хотіли б їй дати. А ось права частина специфічна.
Ми пишемо ключове слово function, потім відкриваємо дужки, перераховуємо список аргументів, закриваємо дужки, відкриваємо фігурні дужки, пишемо |тіло функції|, і закриваємо дужки.
Ми можемо не написати жодного аргументу, тіло може бути пустим, але ключове слово function, дужки і фігурні дужки ви зобов"язані написати!

```
var stupid = function(){}; // це цілком правильний запис! 
// Щоправда, толку від такої функції небагато

```

# Як працюють функції. Оголошення і передача аргументів

Але як це працює? Чому ми у функції wrap_in_tag назвали аргументи str i tagname, а передали туди змінні g i a, як це працює?
Ось ще один приклад для медитації.

```
var he = 'John';
var she = 'Mary';

var merry = function(bride, groom){
	return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}

var happy_message = merry(she, he);

```

В реальному житті функції можна порівняти із обрядами, церемоніями, взагалі, будь-якими процесами.
Як би ви описали інопланетянину, що таке весілля і як воно відбувається?
По-перше, визначимось із мінімальними вимогами. Для весілля потрібно щонайменше двоє людей, наречений і наречена(по можливості, різної статі).
Звичайно, там може бути присутнім багато людей, але справді значущі зміни відбуваються, перш за все, саме у житті цих двох людей.
Отже, нам потрібні двоє. 
Далі, ми опишемо, як це зазвичай відбувається. Наречені вінчаються у церкві, далі реєструють шлюб у загсі, наречений одягає обручку
на палець нареченої, і так далі. 

Насправді, нам не дуже цікаві деталі. Важливий сам підхід, як це описується.
Ми описуємо процес абстрактного весілля(абстрактне весілля, чудово, чи не так? ви вже відчуваєте дух програмування, який витає у таких фразах?), 
те, як воно взагалі відбувається, а не розповідаємо історію чийогось конкретно весілля.
Учасників процесу(весілля) ми називаємо згідно їх ролей(наречений і наречена). 
Коли ми просто описуємо цей обряд, невідомо, чи будуть це Іван і Марія, чи Петро і Ганна, нам це неважливо, ми говоримо "взагалі".


Будь-яке твердження із нашої повсякденної мови може бути віднесене або до абстрактних, або до конкретних.
Наприклад, "Лошади кушают овес и сено, Волга впадает в Каспийское море". Перша частина - абстрактна, т.як ми говоримо про усіх коней узагалі, маючи на увазі якусь всесвітню закономірність.
А друга - це конкретне твердження, т.як мова іде про певну річку(Волгу) і те, що вона робить. 

Будь-який процес має абстрактний формальний опис(як це взагалі робиться), і має конкретні випадки реального свого застосування.
Так ось, це саме те, що ми робимо із функціями! Подивіться ще раз:
```
var merry = function(bride, groom){
	return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}
```
Ми описали абстрактну функцію "одружитися", яка приймає два аргументи(наречену і нареченого), і щось робить(в даному випадку, просто формує привітання для них).
Поки що ніхто ні з ким не одружується насправді, ми лише описуємо процес одруження, як воно має відбуватись.
У програмуванні це називається - ми оголосили функцію.
А вже після оголошення, ми можемо її застосовувати! Тобто, женити конкретних іванів і марійок!

```
var he = 'John';
var she = 'Mary';
var happy_message = merry(she, he);

```
Це - застосування функції, або, як кажуть у програмуванні - виклик. 
Функція merry була викликана, при цьому їй були передані змінні she(в якості аргумента bride) і he(в якості аргумента groom).
Результат роботи функції(строчка) був записаний у змінну happy_message. 

Тут є ще один момент, який необхідно пояснити. У програмуванні функції потрібні, перш за все, для того, щоб проводити обчислення.
Тобто, пілся виконання, функція повинна повернути якийсь результат. Але що буде слугувати результатом функції?
Для цього нам потрібне ключове слово return.
Коли ми пишемо return, це означає: повернути те, що стоїть після return, в якості результата роботи функції, і припинити її подальше виконання.

Зверніть увагу! Функції мають спільний простір імен із змінними!

^

var add_respect = function(sir_name){
	var respectful_name = 'Sir ' + sir_name;
}
console.log(add_respect('John Doe')); // пусто!

// Неправильно, змінна respectful_name буде обчислена, але функція поверне порожній результат!

var foo = 'bar';

var foo = function(str){
	return '<b>' + '</b>';
}

foo(foo);
// нонсенс! може бути тільки одна змінна або функцію з цим іменем! 
// В даному випадку, під іменем foo буде лежати функція, бо вона оголошена пізніше!

^

var add_respect = function(sir_name){
	var respectful_name = 'Sir ' + sir_name;
	return respectful_name;
}
console.log(add_respect('John Doe')); // Sir John Doe

^
Напишіть функцію wrap_h2, яка повертає передану їй строчку, обрамлену в тег h2
```
var str = 'Fireball';

???3%wrap_h2('a') == '<h2>a</h2>'%var wrap_h2 = function(a){ 
	return '<h2>' + a + '</h2>';
}%
//var wrapped = wrap_h2(str);
//console.log(wrapped); // <h2>Fireball</h2>
```
Напишіть функцію round_area(), яка рахує площу кола по переданому їй |діаметру|(вважаючи, що число Пі дорівнює 3.14).
```
???5%round_area(10) == '78.5'%var round_area = function(diameter){
	var radius = diameter/2;
	var area = 3.14*radius*radius;
	return area;
} %

// round_area(10); // 78.5
```
Завдання на додатковий бал: напишіть функцію wrap_in_tag(str, tag), яка повертає строчку, загорнуту в тег, а також функцію wrap_in_div, яка, |використовуючи першу функцію|, загортає строчку в тег div.
```

var str = '2TE10M';
???10%wrap_in_tag('a', 'b') == '<b>a</b>' && wrap_in_div('a') == '<div>a</div>'%
	var wrap_in_tag = function(str, tag){
		var new_str = '<' + tag + '>' + str + '</' + tag + '>';
		return new_str;
	}
	var wrap_in_div = function(str){
		var new_str = wrap_in_tag(str, 'div');
		return new_str;
	}
%
```

Цей приклад настільки важливий, що розберемо його детально.
Ось правильне рішення попередньої задачі:
```
var wrap_in_tag = function(str, tag){
	var new_str = '<' + tag + '>' + str + '</' + tag + '>';
	return new_str;
}

var wrap_in_div = function(str){
	var new_str = wrap_in_tag(str, 'div');
	return new_str;
}

```
Звичайно, ми могли б написати функцію wrap_in_div простіше, 
приблизно так:

```
var wrap_in_div = function(str){
	var new_str = '<div>' + str + '</div>';
	return new_str;
}
```
Але для чого нам заново переписувати усю логіку формування строчки?
У нас же є чудова універсальна функція wrap_in_tag(), отже, ми використаємо її!
Таким чином, ви бачите, що функції можна використовувати одна в одній, і це прекрасно.
Процес розробки програмного забезпечення, грубо кажучи, полягає в написанні спочатку простіших функцій, на основі яких пишуть складніші і специфічніші функції, які реалізовують поставлені задачі.

# Область видимості змінних
Що таке область видимості змінних? Про що йде мова?
Ну, ви вже знаєте, що, наприклад, не можна використовувати змінну раніше, ніж вона оголошена.
```
alert(a); // буде помилка, змінної "а" ще нема
var a = 'Hello!';
```
Тобто, ви вже розумієте, що змінні не можна використовувати де завгодно.
А як бути зі змінними, оголошеними в функції?
```
var fill = function(str){
	var template = '<a>$$$</a>';
	return template.replace("$$$", str);
}
// функція підставляє ваші дані в шаблон
var str = fill('Google'); // '<a>Google</a>'
// а чи доступна нам змінна template, оголошена в функції?
console.log(template);
// Hi!
```
Ні, змінні, оголошені всередині функцій, існують самі по собі, і ніяк не перетинаються із зовнішніми змінними!
А чи можна із функції звернутись до зовнішньої змінної? Так!
Наприклад, ось функція, яка кожен раз буде повертати число, на один більше за попереднє.
^
var get_num = function(){
	var counter = 0;
	return ++counter;
}

get_num(); // 1
get_num(); // 1 :(
get_num(); // 1 :'(...
^
var counter = 0;
var get_num = function(){
	return ++counter;
}

get_num(); // 1
get_num(); // 2 :)
get_num(); // 3 :D fuck yeah!
^
Чому перший приклад неправильний?
Змінна counter буде створюватися кожного разу при запуску функції! І кожного разу вона буде дорівнювати нулю, а потім одиниці!
Кожного разу при запуску функції ця історія буде повторюватися, як у фільмі "День Бабака". Не допускайте такої печалі зі своїми функціями!
Натомість, друга функція звертається до зовнішньої змінної counter.
Ця змінна зберігає своє значення незалежно від функції. Функція лише збільшує його кожного разу на одиницю і повертає!

<div class="quote">
	 Когда-то я был лагерным надзирателем. Возил заключенных в таком же металлическом фургоне. Машина называлась - автозак. В ней помимо общего "салона" имелись два тесных железных шкафа. Их называли стаканами. Там, упираясь в стены локтями и коленями, мог поместиться один человек. Конвой находился снаружи. В железной двери была проделана узкая смотровая щель. Заключенные называли это устройство: "Я тебя вижу, ты меня - нет". Я вдруг почувствовал, как это неуютно - ехать в железном стакане. А ведь прошло шестнадцать лет...

	 С.Довлатов. "Компромисс"
</div>

Отже, із змінними у функціях запам"ятатйте цей принцип: "я тебе бачу, ти мене ні": всередині функцій ми можемо звертатись і до зовнішніх змінних, і до внутрішніх, а ззовні 
добратися до змінних із функцій ми не можемо!
```
var site_domain = 'example.com';

// напишіть функцію get_link(str), яка повертає повний лінк на підрозділ сайту str
// get_link('blog.php') -> 'http://example.com/blog.php'
// доменна адреса має братись із змінної site_domain
???3% get_link('a') == 'http://example.com/a'%
var get_link = function(str){
	return 'http://' + site_domain + '/' + str;
}
 %
```
@@@
@@@

## Гілкування

Джаваскрипт і подібні мови називають також мовами сценаріїв, і це досить влучна назва.
Програма, написана на Джаваскрипті, описує, як будуть розгортатися події на підмостках браузера, що буде показано юзеру що буде робитись із ХТМЛ сторінкою.
Цю паралель можна розвивати і далі, але є дуже суттєва відмінність між програмуванням і театральним сценарієм.
На відміну від театру, де Отелло буде убивати Дездемону кожного разу, скільки буде ставитись п"єса, програмам властива деяка гнучкість, інтерактивність.

Досі все, що ми писали, було простою послідовністю дій: візьми те, запиши туди те, запусти функцію таку. Тобто, наша програма кожного разу працювала б 
по одній і тій же схемі. Однак це не цікаво! На допомогу нам приходить механізм розгалуження, гілкування. 
Гілкування працює так: ми перевіряємо якусь умову, якщо вона вірна - робимо одне, якщо не вірна - робимо інше.
"Якщо це |так|, то зроби це. Якщо це |НЕ так|, то зроби щось інше"

```
var Desdemona_is_guilty = false;

if(Desdemona_is_guilty){ // <- початок гілкування. Ключове слово if, умова Desdemona_is_guilty
	kill('Desdemona');
} else {
	kill('Iago');
}
```
Поки що не заглиблюємось у нюанси, загальна суть того, що відбувається, приблизно зрозуміла.
Припустимо, нам треба написати функцію, яка поверне із двох чисел те, котре найбільше. Ось її реалізація.
```
var get_max = function(a, b){
	if(a > b) {
		return a;
	} else {
		return b;
	}
}

get_max(20, 13); // 20
get_max(1, 2); // 2

```

Давайте тепер розберемось в синтаксисі.
Перше, що ви повинні побачити і запам"ятати - це ключове слово if. З нього починається розгалуження.
В дужках після if ми пишемо те, що ми хочемо перевірити. Наприклад, чи одне число більше за інше.
Після цього ми відкриваємо фігурні дужки, і пишемо те, що виконається, якщо написана нами умова вірна.
Потім ми закриваємо їх, і можемо написати ще одне ключове слово, else, і після нього той код, який виконається, якщо умова НЕ вірна.

Зверніть увагу, що та умова, яку ми пишемо, завжди має лише два варіанти: так або ні, істина або брехня.
Наприклад, " if(вона вагітна) { ...робимо щось одне... } else { ...робимо щось інше... }
Проміжних варіантів не може бути, або вагітна, або ні.

У фігурних дужках ми можемо писати будь-який код: оголошувати змінні, викликати функції, все що завгодно, у т.ч. ще одне гілкування.
Це логічно, адже сам набір дій у тому чи іншому разі може бути яким завгодно. Важливе питання - як ми можемо формулювати умови.

# Перевірка умов

Отже, питання полягає у тому, як ставити питання :)
Давайте придивимось до звичайних побутових формулювань:
"Піди у магазин, купи яєць, а якщо їх не буде, то візьми літр молока".
Якщо перекласти це речення на суху мову програмування, це звучатиме так:
"Піди у магазин. Перевір, чи є там в наявності яйця. Якщо є, то - купи яйця. Якщо ні, то - купи молоко".
Тут ми бачимо усі складові гілкування: умова(є в наявності яйця), план А(якщо яйця є, то купуємо їх), план Б(купуємо молоко).
Ще сухіше:
```
go_to_shop();
if(eggs_available()){
    buy('eggs');
} else {
    buy('milk');
}
```
Крім перевірки на наявність/відсутність чого, можуть бути чисто математичні порівняння, які можна робити ЛИШЕ з числами: більше, менше, більше або дорівнює, менше або дорівнює.
Ось так:
```
if(a > b){ ... } else { ... }
if(a < b){ ... } else { ... }
if(a <= b){ ... } else { ... } // менше або дорівнює
if(a >= b){ ... } else { ... } // більше або дорівнює
if(a == b) { ... } else { ... } // а дорівнює b
if(a != b) { ... } else { ... } // а НЕ дорівнює b
```
^
// неправильний запис оператора "менше або дорівнює"
if(a =< 3){ ... } else { ... }
^
// а отак правильно!
var a = 2;
if(a <= 3){ ... } else { ... } // а отак правильно!
^
Існує також помилка, настільки розповсюджена, що її хочеться розібрати окремо.
Це ситуація, коли замість перевірки на рівність, яка здійснюється оператором "==", змінну присвоюють оператором "=".
Між ними величезна різниця!

^
// Увага, помилка! Замість перевірки на рівність ми ПРИСВОЇМО значення b в а
if(a = b) { ... цей код буде виконуватись майже завжди, бо ми просто запишемо b в а ...} else { ... }
^
// Правильний варіант порівняння двох змінних
if(a == b) { ... } else { ... }
^
Звичайно, інтуїтивно хочеться записати якраз if(a = b), т.як це більш логічно і звично після математичних рівнянь.
Найбільша проблема, що ніякої помилки при цьому не виникне, джаваскрипт виконається нормально, адже сам по собі цей запис є валідним(дійсним, можливим).
Так що, якщо ви одразу не напишете цю перевірку правильно, ви прирікаєте себе на довгі муки в пошуках джерела помилки.

Давайте розберемось, як правильно використовувати гілкування.
Припустимо, нам треба написати функцію, яка пише вітання для юзера в залежності від його статі.
У функцію буде передаватись ім"я юзера, а також стать, а повертати ми будемо строчку із привітанням.
Ця функція, на відміну від попередніх, буде трішки дискримінуючою, тобто, вона буде себе вести по-різному, маючи справу з чоловіками і жінками.

```
var get_sexist_greeting = function(name, gender){ ... }

get_sexist_greeting('John', 'male'); // Hello, mr. John!
get_sexist_greeting('Mary', 'female'); // Hello, ms. Mary!

```
Вочевидь, в функції нам треба буде формувати результат по-різному, в залежності від статі.
Рішення "в лоб" буде виглядати приблизно так:
```
var get_sexist_greeting(name, gender){
	if(gender == 'male'){
		var greet = 'Hello, mr.' + name + '!';
		return greet;
	} else { // females, transgenders and other non-males
		var greet = 'Hello, ms.' + name + '!';
		return greet;
	}
}

``` 
Така функція, в принципі, буде працювати, однак, її можна трішки "покращити"(в хорошому розумінні цього слова).
Гарний програміст старається не писати зайвого коду.
Якщо ми подивимось на цю функцію, можна помітити, що результат відрізняється лише на одну букву.
Більшу частину строчки можна зробити спільною, і варіювати лише невелику частинку, яка є звертанням.
```
var get_sexist_greeting(name, gender){
	if(gender == 'male'){
		var address = 'mr.';
	} else { // females, transgenders and other non-males
		var address = 'ms.';
	}
	var greet = 'Hello, ' + address + ' ' + name + '!';
	return greet;
}
```
Ось так вже значно краще! Ми ввели додаткову змінну, яка позначає частинку звертання і варіюється в залежності від статі, а інша частина строчки залишається спільною для всіх.
Так ми трохи скоротили функцію і зробили її яснішою, читабельнішою.
Вітаю, тепер ви знаєте що таке рефакторинг. Цей термін у програмуванні позначає процес покращення якості коду без зміни результатів його діяльності.

Звичайно, на перших порах вам буде не до якості коду, ви будете старатись написати функції як-небудь, аби тільки вони давали бажаний результат.
Однак, з часом, ваша свідомість як програміста піднесеться на новий рівень, і ви будете піклуватись не тільки про працездатність коду, а і про його читабельність, підтримуваність і красу(така собі піраміда Маслоу духовних потреб програміста ).
В нашій книзі я інколи заоохочуватиму вас до написання якісного коду.
```
// Напишіть функцію get_over_10(), яка приймає число, і повертає його, 
// якщо воно більше 10, а якщо воно менше, то повертає 10.
???4%get_over_10(2) == 10 && get_over_10(23) == 23%
var get_over_10 = function(num){
    var res = num;
    if(num < 10){
        res = 10;
    }
    return res;
}
%
```

```
// Напишіть функцію get_first_positive(), яка повертає перший із трьох аргументів, 
// який буде більше за 0
// Якщо жодне із значень не буде додатнім, поверніть 0
???4%get_first_positive(-1, 2, 12) == 2 && get_first_positive(-1, -2, 12) == 12 && get_first_positive(-1, -2, -12) == 0%
    var get_first_positive = function(a, b, c){
        var res = 0;
        if(c > 0){
            res = c;
        }
        if(b > 0){
            res = b;
        }
        if(a > 0){
            res = a;
        }
        return res;
    }
%
```
# Логічний тип даних

Дотепер ми знали два типи даних: число і строчка. Зараз ви познайомитесь зі ще одним типом даних - логічним.
Кожен тип даних характеризується можливим діапазоном значень.
Давайте згадаємо, які у нас бувають строчки і числа

```
// Строчки
var a = 'Hey, Joe!';
var b = 'I wonder, ' +
'Where you going with that gun in your hand?';
var c = "23"; // це теж строчка, не забувайте
var d = 'Number Pi is ' + 3.14; // якщо ми об"єднуємо число і строчку, виходить строчка

// Числа
var x = 13;
var pi = 3.14;
var dead = -1;
var sum = x + dead;
```
А які можуть бути значення у "логічного типу даних"?
```
var she_is_pregnant = false;
// ... щось відбулося ...
she_is_pregnant = true;
```
Усього два значення - true i false! Чорне і біле, правда і брехня. Дуже просто запам"ятати.
Пишуться вони як строчки, тільки без лапок.
```
var a1 = 'true'; // string
var a2 = true;

var b = a1.replace('ru', 'ua'); // tuae
var c = a2.replace('ru', 'ua'); // ERROR! Метод replace є тільки у строчок!
```
Для чого потрібні такі змінні? Для використання у перевірці умов!
Згадайте, що ми пишемо в дужках після if:
```
if(a > b) { ... } else { ... };

if(my_age > 18) { 
	// sell me some cigars, now!
} else {
	// please, don't tell my mom!
};

```
Якщо ми пишемо 2 + 3, яке значення має цей вираз? Правильно, 5.
А якщо ми пишемо 5 > 2, то яке значення буде у цього виразу? Звісно, false!
Кожен раз, коли ми пишемо щось у дужках після if, цей вираз обчислюється, і ми дивимось, істинний він чи ні.
Подивимось ще раз на приклад з початку розділу, тепер він буде вам зрозумілий.
```
var Desdemona_is_guilty = false;

if(Desdemona_is_guilty){
	kill('Desdemona');
} else {
	kill('Iago');
}
```
Ось тут, на щастя, буде убитий Яго, а не невинна Дездемона!
Ми присвоїли у змінну Desdemona_is_guilty значення false, отже, буде виконана друга частина гілкування, та, котра йде після else!

В if можна передавати не тільки змінні, а і складні конструкції, наприклад, виклики функцій.
Припустимо, хлопчик хоче придбати цигарок.
Ми будемо перевіряти за допомогою спеціальної функції, чи можна йому продати цигарки.

```
var we_can_sell_cigars = function(age){
	var permit = age >= 18; // у змінну permit попаде логічне значення, true або false!
	return permit;
}

var boy_age = 17;

if(we_can_sell_cigars(boy_age)){
	console.log('Fuck yeah!');
} else {
	console.log('Ok :(');
}
```
Що буде виведене в результаті? Звичайно, Ok :(
Ще раз подумаємо, що тут відбувається.
Ми перевіряємо, чи можна продати хлопцю цигарки. У нас є конструкція if, значить, перш за все, ми 
обчислюємо значення в дужках. У дужках у нас викликається функція we_can_sell_cigars, при чому їй передається вік хлопчика(17 років).

Всередині цієї функції ми приймаємо вік як аргумент age, і записуємо в змінну permit, чи не менший цей вік за 18.
В даному випадку, таки менший, отже, змінна permit буде дорівнювати false.
Ми повертаємо цю змінну як результат виконання функції we_can_sell_cigars в наш if, він бачить, що діла неважні(йому прийшло false), і розчаровує хлопчика,
направляючи його шляхом else.

# Кілька умов за раз

Нам треба написати функцію, яка б допомогла хлопцю розібратися, що з ним зараз відбувається.
З одного боку, ми будемо перевіряти, чи не вагітна його дівчина, а з іншого, чи кохає він її.
Результат(його поточний стан) буде таким:
а) якщо вагітна і він кохає її - 'happy'
б) якщо вагітна і НЕ кохає - 'in trouble'
в) якщо НЕ вагітна і кохає - теж 'happy'
г) якщо НЕ вагітна і НЕ кохає - 'OK'

Отже, як нам написати таку функцію?
В принципі, це не так складно, якщо розуміти, що гілкування може бути скільки завгодно вкладеним.

```
var check_state = function(pregnant, in_love){
	if(pregnant){
		if(in_love){
			var state = 'happy';
		} else {
			var state = 'in_trouble';
		}
	} else {
		if(in_love){
			var state = 'happy';
		} else {
			var state = 'OK';
		}
	}
	return state;
}
```
В принципі, працездатно, але ж так громіздко!
Глибокі рівні вкладеності погіршують читабельність.
```
var check_state = function(pregnant, in_love){
	if(pregnant AND in_love){
		var state = 'happy';
	}
	if(pregnant AND !in_love){
		var state = 'in_trouble';
	}
	if(!pregnant AND in_love){
		var state = 'happy';
	}
	if(!pregnant AND !in_love){
		var state = 'OK';
	}
	return state;	
}
```

Отак вже краще!
Отже, коли ми пишемо умову, ми можемо вживати ключове слово AND(називається "логічне AND").
В результаті, значення всього виразу pregnant AND in_love буде true, тільки якщо і pregnant, i in_love будуть true.
Якщо ж хоч одне щось із них буде false - весь вираз буде рівним false!

І ще цікава річ, яку ви, сподіваюсь помітили - знако оклику перед змінною. Він означає заперечення.
Тобто, !love означає НЕ love.
```
var guilty = true; // true
var guiltless = !guilty; // false
```
Отже, знак оклику перетворює логічну змінну на її протилежність.

Крім логічного AND, є ще і логічне OR! Воно допоможе нам покращити код.
Ми бачимо, що два випадки є аналогічними(дають один і той же результат - happy).
Отже, ми можемо об"єднати їх в один.

```
var check_state = function(pregnant, in_love){
	if((pregnant AND in_love) OR (!pregnant AND in_love)){
		var state = 'happy';
	}
	if(pregnant AND !in_love){
		var state = 'in_trouble';
	}
	if(!pregnant AND !in_love){
		var state = 'OK';
	}
	return state;	
}
```
Уже одним кейсом менше! Як ви можете побачити, складова else не є обов"язковою!
Логічне OR дає true, якщо хоча б один із його складових є true.
Але ми можемо ще спростити нашу функцію!
Якщо придивитись, у першій умові не важливо, pregnant чи не pregnant, головне щоб in_love було true.

```
var check_state = function(pregnant, in_love){
	if(in_love){
		var state = 'happy';
	} else {
		if(pregnant){
			var state = 'in_trouble';
		} else {
			var state = 'OK';
		}
	}
	return state;	
}

```
Мене, чесно кажучи, напрягає писати по багату разів var, а якщо ще відвертіше казати, то це і взагалі неправильно.
Тому спробуємо оголосити змінну один раз на початку, присвоївши їй якесь значення по замовчуванню
```
var check_state = function(pregnant, in_love){
	var state = 'happy';
	if(!in_love){
		if(pregnant){
			state = 'in_trouble';
		} else {
			state = 'OK';
		}
	}
	return state;	
}
```
Ось це вже мені подобається!
var пишемо один раз. Тобто, змінна гарантовано оголошується на початку, а далі, в певних ситуаціях, може бути перезаписана.
Вітаю, ви ще раз попрактикувались у рефакторингу, і розібрались, як вправлятись із логічними запереченням(!), AND i OR.

@@@
@@@
## Об"єкти
Для чого потрібні об"єкти, можна легко зрозуміти, згадавши один із попередніх прикладів.
```
var he = 'John';
var she = 'Mary';
var merry = function(bride, groom){
	return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}
var happy_message = merry(she, he);
```
Ця функція працює непогано, але вона занадто проста. Зазвичай в житті все буває складніше, наприклад, працівники ЗАГСу, йомвірно, перевірять, чи є молодята різної статі,
або чи не є один із них уже одруженим на даний момент. Отже, як ми можемо в нашій функції запобігти багатоженству?
Що ж, ми можемо ввести додаткові логічні змінні, які будуть зберігати інформацію про поточний статус.
```
var person_1_name = 'Petro';
var person_1_status = 'unmarried';
var person_2_name = 'Mary';
var person_2_status = 'divorced';

var merry = function(name1, status1, name2, status2){
    if(status1 == 'married' OR status2 == 'married'){
        return 'Marriage failed, error code 400';
    }
	return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
```
Однак, це ще далеко не все. У нас в Україні одностатеві шлюби заборонені, тому ми ще маємо перевірити, щоб стать молодят відрізнялась!
```
var person_1_name = 'Petro';
var person_1_status = 'unmarried';
var person_1_gender = 'male';
var person_2_name = 'Mary';
var person_2_gender = 'female';

var merry = function(name1, status1, gender1, name2, status2, gender2){
    if(status1 == 'married' OR status2 == 'married'){
        return 'Marriage failed, error code 400';
    }
    if(person_1_gender == person_2_gender){
        return 'Homosexual marriages prohibited!';
    }
	return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
```
Вам вже страшно? Мені, особисто, так. 6 аргументів - це вже занадто!
На кожну людину нам треба завести по 3 змінні, що означають якісь її характеристики: ім"я, стать, шлюбний статус.
Але ж є ще прізвище, адреса, вік... Так ми заморимось створювати змінні :)

Ідея об"єктів полягає у тому, щоб згрупувати разом змінні, які позначають властивості одного і того самого предмета.
У вас бувала ситуація, коли весь робочий стіл завалений ярликами і файлами? Як ви з цим боролися? В ідеалі, треба створити тематичні папки,
і розкладати файли по ним. Так само ми вчинимо і з нашими змінними. Об"єкти - це "папки", у які ми будемо складати змінні("файли").
```
var person_1 = {
    name: 'Petro',
    status: 'unmarried',
    gender: 'male'
}

var person_2 = {
    name: 'Mary',
    status: 'divorced',
    gender: 'female'
}
var merry = function(person1, person2){
    if(person1.status == 'married' OR person2.status == 'married'){
        return 'Marriage failed, error code 400';
    }
    if(person1.gender == person2.gender){
        return 'Homosexual marriages prohibited!';
    }
    // !!! дуже важливий момент! Якщо все ок, і пару ми можемо поженити, ми повинні змінити їх статус!
    person1.status = 'married';
    person2.status = 'married';
	return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
```
Оце вже інша справа! Давайте розбиратись.
```
var person_1 = {
    name: 'Petro',
    status: 'unmarried',
    gender: 'male'
}
```
Ось це - справжнісінький об"єкт! Це як наче папка, в якій лежать файли "1.txt", "КУРСОВА!!!!!.doc", "wfnrw7yg9834tn34kt.jpg" і інші.
В якості "файлів" у нас - змінні. Ліва частина об"єкту оголошується так само, як і змінна - var %somename%.
Права частина загорнута у фігурні дужки, і містить перелік змінних, які вкладені в об"єкт.
Зліва пишуться імена змінних(ключі), а справа - значення. Змінні об"єкта називаються властивостями або полями об"єкта.

В об"єкт можна покласти будь-яку змінну, наприклад, логічну або число. Або навіть інший об"єкт!(адже ми можемо покласти папку в папку)
```
var men = {
    name: 'Ivan',
    age: 25,
    gender: 'M',
    wife: {
        name: 'Ann',
        age: 23,
        gender: female,
    }
}
```
Пари "ключ/значення" розділені комами(останню кому бажано не ставити).

А тепер подивимось, як поводитись із об"єктами.
По-перше, як добратись до його властивостей - дуже просто, через крапку!
```
men.name; // "Ivan"
men.age; // 25
men.wife.gender; // "female"
```
Як бачите, рівень вкладеності може бути яким завгодно глибоким!
Можливо, нотація через крапку вам буде незвичною спочатку, т.як асоціюється із закінченням речення або скороченням.
Згадайте компанію Яндекс, яка усі свої сервіси називає через крапку: "Яндекс.Директ", "Яндекс.Розклади" і т.д. Вочевидь, таке йменування виникло по мотивам об"єктної нотації.

# Пусте значення(undefined)

Що буде, якщо ми звернемось до змінної, якої нема?(яку ми не оголошували)
Виникне помилка!
```
alert(some_stupid_name); // помилка!
```
А от якщо спробувати пошукати властивість об"єкта, якої нема, нам це пробачать.
Просто ми отримаємо пусте значення, яке називається undefined.
```
var a = {
	ene: 'bene',
	kvinter: 'finter',
}
console.log(a.zhaba); // undefined
```
Undefined - це таке спеціальне значення, єдине у своєму роді.
Воно трохи схоже на false, тим, що якщо ви будете перевіряти його, воно буде давати негативний результат
```
if(a.zhaba){
	// цей код ніколи не виконається
} else {
	// а оцей - так
}	
```
Однак його не слід плутати із false. Заперечення і відсутність будь-чого - це зовсім різні речі.
Наприклад, вам задають питання, "Чи плямкаєте ви, коли гризете батарею?". Питання поставлене так, що очікується 
відповідь у формі "так" або "ні", true або false. Але, скоріше за все, ви не скажете ні "так", ні "ні", а спробуєте довести своєму співрозмовнику, що ви не гризете батареї.
Ось це і буде undefined.
```
var person = {
	name: 'Zigmund',
	smokes: false
}
if(person.smokes == undefined){
	...
	// дії, якщо це поле відсутнє
}
if(!person.smokes){
	// дії, якщо людина не курить
}
``` 

# Що можна робити з об"єктами

Об"єкти, як ви, можливо, здогадались, є ще одним типом даних(нарівні із числами, строчками і логічними значеннями).
Одна з ними не можна робити майже нічого з того, що ми звикли робити з іншими типами даних.
Їх не можна додавати(віднімати, ділити і т.п.), складати у строчку.

Знову ж таки, звернемось до аналогії з папками. Ви не можете редагувати папку(що ви будете в ній редагувати?!).
Ви можете редагувати файл у папці, можете прибрати файл із папки, додати файл у неї, але сама папка ніяких власнивостей не має, окрім імені.
Давайте подивимось, як виглядають ці операції з об"єктами:
```
var car = {};// створюємо пустий об"єкт

car.power = 1000; // додаємо нову властивість(змінну) в об"єкт, ключ "power", значення 1000.
car.color = 'red';
сar.brand = 'Ferrari';
// тепер подивимось, що вийшло
console.log(car); // Object {power: 1000, color: "red", brand: "Ferrari"} 
// як бачите, коли ми виводимо об"єкт в консоль, він показується нам з усіма властивостями

// Перевіримо, чи є у об"єкта властивість
if(car.color){ ... }

//Однак, ця перевірка не спрацює, якщо в полі color буде значення 0 або false.
//Для того, щоб відрізнити відсутність поля від поля зі значенням false, пишемо так
if(car.color != undefined){ ... }

// спробуємо видалити властивість
delete car.color; // насправді, вам майже не знадобиться ця операція

// редагування змінних об"єкта не відрізняється від початкового присвоєння
car.color = 'yellow'; // тепер колір змінився

// подивимось окрему властивість
console.log(car.color); // 'yellow'

```
Також ми можемо отримати ключ, ім"я якого лежить у змінній!
Для цього існує спеціальна нотація.
```
var man = {
	name: 'Jimmi',
	surname: 'Hendrix',
	job: 'genius',
	age: 28
}

var key = 'name';

console.log(man.name); // Jimmi
//!!! Увага !!!
console.log(man[key]); // Jimmi!

key = 'age';
man[key]++;
console.log(man.age); // 29
console.log(man['age']); // 29
```
Як бачите, є два способи звернутись до ключа об"єкта: через крапку, написавши її безпосереднє значення,
або через квадратні дужки, передавши строчку, яка означає ім"я ключа! Можна передавати безпосередньо строчку або змінну, яка містить строчку.
^
var obj = {a: 2, b: 42, c: 0}
obj[a]; // помилка! Змінної "а" не існує!
^
var obj = {a: 2, b: 42, c: 0}
obj['a']; // good!

//
var k = 'c';
obj[k]; // '0'
^
Такий запис нам знадобиться, коли ми наперед не знаємо, до якого ключа звернутись.

Для початку вистачить. Трохи поліпимо пасочки.
```
// Напишіть функцію create_user, яка приймає ім"я юзера і його прізвище, 
// і повертає об"єкт із полями name і surname
???4%create_user('Ivan', 'A').name === 'Ivan' && create_user('Ivan', 'A').surname == 'A'%
    var create_user = function(n, s){
        var user = {
            name: n,
            surname: s
        }
        return user;
    }
%
```
```
// Напишіть функцію setAge, яка буде приймати об"єкт, що позначає юзера, і число, 
// записуватиме цьому юзеру в поле age це число, і повертатиме об"єкт.
???4%setAge({}, 12).age === 12%
    var setAge = function(user, age){
        user.age = age;
        return user;
    }
%
```
```
/* 
Напишіть функцію celebrateBirthday, яка приймає об"єкт, і дивиться, 
чи є у нього поле age. Якщо таке поле є, вона збільшує його значення на одиницю.
Якщо такого поля нема, то нічого не робить. 
В будь-якому разі, функція повертає об"єкт, який прийняла. 
*/
???4%celebrateBirthday({age: 30}).age === 31 && celebrateBirthday({}).age == undefined%
    var celebrateBirthday = function(user){
        if(user.age !== undefined){
            user.age++;
        }
        return user;
    }
%
```
```
/* 
Напишіть функцію getKey, яка приймає об"єкт і ім"я ключа, і 
*/
???4%celebrateBirthday({age: 30}).age === 31 && celebrateBirthday({}).age == undefined%
    var celebrateBirthday = function(user){
        if(user.age !== undefined){
            user.age++;
        }
        return user;
    }
%
```


<!--Трохи попрактикуємось

Функція-класифікатор геометричних фігур classify(a, b, c) приймає 3 аргументи, які характеризують геометричну фігуру.
Перший аргумент - чи рівні її сторони, другий - кількість сторін, третій - наявність прямих кутів.
Можливі значення, які повертає функція: 'квадрат', 'ромб', "прямокутник", "чотирикутник", "трикутник", "прямокутний трикутник", "рівносторонній трикутник", "прямокутний трикутник"
В усіх інших випадках вона повертає "не знаю".
```
classify(true, 3, false); // "рівносторонній трикутник"
???3% % 
function classify(has_equal_sides, side_num, right_angle){
	if(side_num == 3){
		if(has_equal_sides){
			return '';
		}
		if(right_angle){
			return '';
		}
		return;
	}
	if(side_num == 4){
		if(has_equal_sides AND right_angle){
			return 'квадрат';
		}
		if(right_angle){
			return 'прямокутник';
		}
		if(has_equal_sides){
			return 'ромб';
		}
		return 'прямокутник';
	}
	return 'не знаю';
}
%
```
-->
# Методи

А що буде, якщо запхнути в об"єкт функцію?
В принципі, вона працюватиме, так як треба, як і звичайна функція.
```
var user = {
    name: 'Konrad',
    surname: 'Mikhelson',
    get_fullname: function(name, surname){
        return 'I am ' + name + ' Karlovych ' + surname;
    }
}
```
Начебто, непогано.
```
var full_name = user.get_fullname(user.name, user.surname); // I am Konrad Karlovych Mikhelson

var full_name2 = user.get_fullname('Klara', 'Novikova'); // I am Klara Karlovych Novikova
// ???
```
В принципі, можна було б і так писати код, і ніхто б не скаржився. Але є один механізм, який може спростити нам життя.
Цей механізм, як і багато інших, запозичений із живої мови, він дуже потужний, але, як це буває, ми настільки звикли до нього, що не помічаємо.
Трошки віршів:
```
Не слухала Катерина
Ні батька, ні неньки,
Полюбила москалика,
Як знало серденько.

Полюбила молодого,
В садочок ходила,
Поки Катерину, Катеринину долю
Там занапастила.
```
Стоп-стоп! Щось не те!)))
Тарас Шевченко був майстром української словесності, він вправно використовував усі можливості української мови, у тім числі... займенники!
Тому-то і вірші у нього виходили добре.
```
Не слухала Катерина
Ні батька, ні неньки,
Полюбила москалика,
Як знало серденько.

Полюбила молодого,
В садочок ходила,
Поки себе, свою долю
Там занапастила.
```
Себе! Свою! От так набагато краще! Як бачите, займенники дуже економлять наш час
 і додають виразності і чіткості нашим висловлюванням(якщо правильно ними користуватись).
Тож, навіщо постійно писати ім"я об"єкта, про який і так зрозуміло, що йде мова?
Тепер подумаємо, якби виглядала життєва історія Катерини на джаваскрипті.
```
var Kateryna = {
    gender: 'female',
    status: 'happy',
    future_children: 'good',
    diddle: function(person){ // функція, яка відповідає за занапащення
        person.status = 'unhappy';
    },
    love: function(who, whom){ // передаємо два аргументи, перший - 
    //це хто любить(у нас це буде Катерина), другий - кого люблять
        if(whom.type == 'moscal'){
            // poor Kateryna!
            who.diddle(who); // сама себе занапастила(
            who.future_children = 'bastards';
        } else {
            who.future_children = 'good boys and girls';
        }
    }
}

Kateryna.love('moscal'); // :--(
console.log(Kateryna.status); // unhappy
console.log(Kateryna.future_children); // bastards
```
На жаль, полегшити тяжку долю Катерини ми не в змозі, але, принаймні, ми можемо 
зробити наш код, який описує її страждання, більш красивим.
Що з нашим кодом не так? У ньмоу постійно передається туди-сюди об"єкт Kateryna, 
над яким відбуються модифікації. Хоча ж і так ясно, що якщо у Катерини є метод "занапастити себе",
то його виконання повинне занапастити саме Катерину, і ні кого іншого!

У джаваскрипті є чудовий механізм для методів, який дозволяє використовувати займенники.
Замість того, щоб постійно передавати об"єкт Катерини в аргументах, ми просто будемо вживати займенник "себе"
(до речі, в англійській мові його нема, у джаваскрипті вживається ключове слово this).
```
var Kateryna = {
    gender: 'female',
    status: 'happy',
    future_children: 'good',
    diddle: function(){ // занапащаємо самих себе!
        this.status = 'unhappy';
    },
    love: function(whom){ // аргумент who уже не потрібен, замість нього ми напишемо this!
        if(whom.type == 'moscal'){
            // poor Kateryna!
            this.diddle(); // занапащаємо самих себе
            this.future_children = 'bastards';
        } else {
            this.future_children = 'good boys and girls';
        }
    }
}
```
Як бачите, коли ми викликаємо функцію як метод об"єкту, всередині функції сам цей об"єкт стає доступним через ключове слово this.
Це дуже, дуже важливий момент, читайте попереднє речення і медитуйте над ним, 
поки до вас не прийде розуміння. Ось простіші приклади для засвоєння:
```

var car = {
    color: green,
    brand: 'Mazda',
    getColor: function(){
        return this.color;
    }
}

car.getColor(); // 'green'

car.setColor = function(color){
    this.color = color; 
    //функція нічого не повертає, але вона записує в наш об"єкт новий колір!
}
car.setColor('red');
car.getColor(); // 'red'
```

Звичайно, ми могли б тут вчинити і простіше - записати строчку прямо в поле color
```
car.color = 'red';
car.getColor(); // 'red'
```
Але часто спеціальні функції, які записують дані в об"єкт, бувають корисні,
т.як ми можемо кастомізувати їх поведінку.
```
var car = {
    brand: 'Ford',
    setColor: function(color){
        if(this.brand == 'Ford' AND color !== 'black'){
            // Error! Ford should be black!
            return ;// нічого не робимо, припиняємо виконання функції
        }
        this.color = color; 
    }
}

car.setColor('green'); // не вийде!
car.setColor('black'); // Ok, Ford is black!
car.color; // 'black'
```
За допомогою об"єктів і їх методів ми можемо моделювати(імітувати) поведінку реальних об"єктів.
У програмістів з великим стажем інколи розвиваються сильні професійні деформації, 
внаслідок яких, усі події свого життя вони спримають як сукупність об"єктів, у яких викликаються певні методи.
Наприклад,
```
var man = {
	name: 'Sergiy',
	job: 'programmer',
	status: 'sleeping', // дефолтне значення що він зараз робить
	getStatus: function(){
		return this.status;
	}
	// тут іде перелік методів - все, що він може робити
	sleep: function(){}, // чудова фукнція
	eat: function(){
		/* ... */
	},
	shit: function(){
		/* ... */
	},
	drink: function(){
		/* ... */
	},
	code: function(){
		/* ... */
	},
	// і т.д.
};

man.getUp();
man.eat('banana');
man.drink('tea');
man.goTo('work');
man.getStatus();// coding
man.goTo('home');

// через кілька років
var wife = get_wife();// реалізація цієї функції для багатьох програмістів дещо незрозуміла
wife.wakeUp(man);
var food = wife.cook('breakfast');
food;// 'some awesome breakfast with muffins'
man.eat(food);
man.feelGood();
```

У реальних буденних задачах веб-програмування вам навряд чи доведеться імітувати реальні процеси по типу поїдання бананів.
В більшості випадків, за допомогю об"єктів будуть описані елементи веб-сторінки, а операції, які ви можете зробити з ними, будуть методами.

# Ще раз про стандартні методи

Тепер ви можете свіжим оком подивитись на стандартні методи, які є, наприклад, у строчок.
```
var str = 'ABCDEFG';
var a = str.charAt(2); // 'C' !!!
```
Наприклад, метод .charAt(), який повертає символ по номеру.
Тільки чому він повернув C, а не В, адже другий по порядку символ - це B?
Справа в тому, що нумерація в джаваскрипті починається з нуля.
```
a = str.charAt(0); // 'A'
```
Так склалось історично, просто прийміть це як є. Цей же принцип відноситиметься і до інших переліків у джаваскрипті.

Але головне питання не в цьому. str - це ж наче просто строчка, і аж ніяк не об"єкт, звідки у неї береться метод charAt?
Відповідь: це такий хитрий трюк від розробників джаваскрипта, щоб полегшити ваше життя.
Звичайно, str з усіх сил старається переконати вас: "Я строчка-строчка-строчка, я зовсім не об"єкт". І str таки дійсно не об"єкт, але деякі властивості об"єкта має.
Це оці стандартні методи. Однак спроба присвоїти строчці якесь поле самотужки не увінчається успіхом.
^
var fruit = 'pear';
fruit.color = 'pink'; // поки все ок, помилки не виникне
console.log(fruit.color); // undefined!
^
var fruit = {name: 'pear'};
fruit.color = 'pink';
console.log(fruit.color); // 'pink'
^
Отже, строчки і числа у джаваскрипті є звичайними строчками і числами, які інколи дозволяють себе вести з ними, як з об"єктами.
Такий їхній лібералізм і доступність значно полегшує життя.
Уявімо, якби усі стандартні методи були функціями.
```
// припустимо, ми маємо функцію charAt(), яка робить те саме, що і метод
var abyrvalg = 'abyrvalg';
var b = charAt(abyrvalg, 1); // 'b'
//і тут раптово!
var charAt = function(str, num){
	return 'ololo';
}

var y = charAt(abyrvalg, 2); // 'ololo' !!!
```
Як бачите, з функціями треба бути обреженим, т.як їхні імена не повинні збігатися з іменами інших функцій і змінних.
Тому, дуже зручно, що більшість стандартних функцій працюють як методи.
Не страшно їх перевизначити, і менше аргументів передавати!

# Об"єкт як словник

Ще одне застосування джаваскриптових об"єктів, окрім моделювання реальних предметів - це функція "словника".
Як працює словник? Ми шукаємо у ньому слово, а він повертає нам його значення.
Так само можна використовувати і об"єкти!
За домопогою них можна співставляти строчки.
Припустимо, ми хочемо написати функцію, яка буде аналізувати українські автомобільні номери.
На вхід ми будемо подавати номер, цільною строчкою, а на виході хочемо отримати об"єкт із його властивостями: область, номер і серія.
```
var plate = 'АН 2755 КК';
plate = parse_plate(plate); 
console.log(plate); // {region: 'Donetsk', number: '2755', suffix: 'KK'};
```
Для того, щоб написати таку функцію, нам знадобляться деякі строкові методи.
Ми маємо строчку 'АН 2755 КК', з якої нам треба "вирізати" перші дві букви, потім цифри, а потім останні дві букви.
Для цього є метод .slice(start, end), який повертає частину строчки між позиціями start і end.
```
var plate = 'АН 2755 КК';
var region = plate.slice(0, 2); // 'AH', символ під позицією end не включається
var number = plate.slice(3, 7); // 2755
```
Ну, частинки номеру ми сік-так виріжемо, а як бути із регіонами?
Нам треба записати, що АН - це Донецька область, АА - Київ і так далі.
Можна, звичайно, зробити це гігантським if/else'ом
```
if(region_code == 'АН'){
	region = 'Donetsk';
} else if(region_code == 'AA'){
	region = 'Kyiv';
} else if(...){ 
	... // і так далі
}
```
Цей спосіб добре підійшов би, якби вам платили не за виконану роботу, а за обсяг написаного коду. Тоді так, це було б чудовим рішенням.
Однак, якщо ви цінуєте лаконічність(а вам доведеться її цінувати, якщо не хочете загрузнути по коліна в коді), то є кращий варіант.
```
var region_names = {
	AA: 'Kyiv',
	AH: 'Donetsk',
	AP: 'Zaporizhzhya',
	...
}
var region_code = 'AP';
var region = region_codes[region_code]; // 'Zaporizhzhya'
// !!!
```
Отак набагато краще!
region_names - це об"єкт, який виконує роль словника, він дозволяє, знаючи код області, отримати її назву.
Так як ім"я ключа(код області) нам невідоме наперед, ми шукаємо потрібний елемент у об"єкті за допомогою нотації квадратних дужок.
Давайте тепер спробуємо це склеїти у функцію
```
var parse_plate = function(plate){
	var region_names = {
		AA: 'Kyiv',
		AH: 'Donetsk',
		AP: 'Zaporizhzhya',
		/* і т.д. */
	}
	var region_code = plate.slice(0, 2);
	var number = plate.slice(3, 7);
	var suffix = plate.slice(8, 10);
	return {
		region: region_names[region_code],
		number: number,
		suffix: suffix
	}
}

```

@@@

