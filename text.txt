### Вивчи Javascript - заради добра, заради України!

@@@
Javascript - це приємна і красива мова програмування, яка стає дедалі більш популярною по всьому світу.
Якщо ви ніколи не займались програмуванням, то Javascript цілком підійде в якості першої мови.
В Україні для вивчення Javascript є ще кілька вагомих підстав: ставши успішним JS-програмістом, ви не тільки покращите свій фінансовий стан, отримаєте цікаву роботу, а і 
допоможете нашій державі! Працюючи з іноземними замовниками, ви зміцнюєте нашу валюту, піднімаєте ВВП, покращуєте міжнародний імідж України!
Отже, перефразовуючи Ільфа і Петрова, "Старанно вивчаючи джаваскрипт, ти допомагаєш суспільству!" (і собі :)

Цей підручник написаний в першу чергу для людей, які не мали раніше досвіду програмування, але знайомі із HTML. Я постарався максимально детально описати базові 
поняття джаваскрипта, так щоб це було зрозуміло всім. Адже, якщо ви ніколи не мали справи з програмуванням, то навіть будь ви суперрозумник із височенним IQ, все одно багато моментів для вас будуть незрозумілими.
Якщо ж ви, читаючи цей підручник, відчуватимете, що автор розсусолює, занадто детально поясню елементарні речі - що ж, вітаю, можете потішитись, ви розумна людина і ваш мозок сприймає все нове швидше, аніж у інших людей!

Підручник складається з двох глобальних частин: перша вас знайомить із основами ядра джаваскрипт, друга розказує про те, як використовувати джаваскрипт в реальних умовах при 
роботі із ХТМЛ сторінками у браузері.

У підручнику я стараюсь пояснювати теорію і одразу підкріплювати її практикою. Але мушу попередити усіх, хто рветься одразу в бій: перші ніж ви зможете робити більш-менш серйозні практичні завдання, вам треба буде виконати багато 
примітивних, "штучних" прикладів. 
Так що запасіться терпінням, і будьте готові вирішувати задачі типу "У Петрика 2 шоколадки, а у Марійки одна, скільки у них шоколадок разом?", тільки в контексті програмування.
Якщо ви, наприклад, власник інтернет-магазину, і хочете навчитись, як доробити якийсь вордпрес-модуль, щоб він працював, так як вам хочеться - вам цей підручник навряд чи допоможе.
Тобто, він вам допоможе, тільки якщо ви ретельно прочитаєте його від початку до кінця, а шукати якихось конкретних рецептів тут не треба.
Підручник розбитий на кілька розділів, які будуть додаватись по мірі написання, кожен розділ містить теорію, приклади коду, завдання.
Також ви можете писати свої коментарі і питання по матеріалу, а автор і інші користувачі зможуть вам відповісти.

Отже, вирушаємо!
<div style="margin-top:100px;"></div>
<img src="vt.jpg">
@@@
@@@
##Зміст



<ul id="zmist">
</ul>

@@@
@@@
## Початок знайомства з Javascript. 
# Що таке Javascript і чим він пахне


Я не буду тут вам переказувати історію винекнення Javascripta, у цьому нема сенсу, перейдемо до суті.
З самого початку Javascript задумувався як мова, як допоможе зробити веб-сторінки інтерактивними.
(нагадую, що читання цього підручника має сенс тільки для тих, хто більш-менш знайомий з основами HTML).
Але як це часто буває з веб-технологіями, автори задумували одне, а вийшло щось інше. Javascript давно переріс рамки "мови простеньких скриптиків",
на ньому тепер пишуться дуже великі і складні програми, апплікейшни, ну от хоча б Gmail(можливо, він вам не здається складним, але повірте - досить і досить серйозний застосунок).
За допомогою джаваскрипта простенькі ХТМЛ сторінки по типу "Це моя домашня сторінка, ось моє фото, а ось мій кіт" переросли у серйозні інтерактивні застосунки.
Однак джаваскрипт виявився настільки кльовою мовою, що її, трошки підлампичивши, адаптували і для зовсім інших задач, не пов"язаних з вебом(NodeJS, який працює на сервері, і інші технології).
Так що, повторюсь, якщо ви ще сумніваєтесь - джаваскрипт це дуже цікава технологія, яка застосовується у багатьох різноманітних сферах, але перш за все - у вебі, і її, без сумніву, варто вивчати.

У нашому підручнику ми сконцентруємось на традиційній формі джаваскрипта. Мова іде про джаваскрипт у браузері, де його задача - маніпулювати ХТМЛ сторінкою.
У цій сфері джаваскрипт є повним монополістом. Річ у тім, що кожна мова програмування потребує програму, яка б її інтерпретувала.
Наприклад, ХТМЛ - це просто набір символів, текст, і тільки у браузері він перетворюється на барвисту веб-сторінку. Чому? Бо кожен браузер "вміє" інтерпретовувати ХТМЛ, себто, робити із гів... із текста картинку.
Так ось, єдиною мовою програмування, яку також можуть інтерпретовувати усі браузери, є Джаваскрипт. Так склалось.
Це значить, якщо ви хочете додати інтерактивності свої веб-сторінці, ви можете зробити це тільки із допомогою джаваскрипта.

Отже, які задачі вирішує джаваскрипт? Ви знайомі із ХТМЛ, який теж, в принципі, є мовою програмування. Однак, який би прекрасний не був ХТМЛ і його супутник ЦСС, вони обмежені у своїх можливостях - вони статичні.
Припустимо, ви верстаєте меню, і хочете, щоб кожна його кнопка при наведенні змінювала колір. Без проблем, за допомогою CSS :hover ви можете це зробити.
А як зробити, щоб ця кнопка змінила свій колір ЛИШЕ ОДИН РАЗ? На жаль, ХТМЛу і ЦССу ця задача не до снаги.
Натомість, це може зробити джаваскрипт. Як це робиться - пояснюю "на пальцях".
У джаваскрипті ми можемо писати "хендлери" - це певні набори дій, які відбуваються у разі, якщо юзер зробить певну дію.
Наприклад, "якщо юзер клікнув по кнопці... сховати її". У нашому випадку, нам треба, щоб коли юзер кліка по кнопці, 
ми перевіряли: чи клікав він по ній до цього. Якщо вже клікав хоча б раз, то нічого не робимо. Якщо ще не клікав, то змінити колір.
Наш уявний код виглядав би так:
```
КОЛИ юзер клікає по кнопці
	1. Подивитись, чи не клікав він по ній до цього
	2. Якщо ще ні разу не клікав, змінити її колір
	3. Якщо вже клікав, не робити нічого
```
Для порівняння, ось код на справжньому джаваскрипті, який реалізовує цю задачу:
```


var button_clicked = false;
$("button").click(function(){
	if(!button_clicked){
		$(this).css('color', 'red');
		button_clicked = true;
	} 
	else {
		// do nothing!
	}
})
```

Страшно? Сподіваюсь, що ні, а якщо і так, то не бійтеся, ми дуже скоро розберемо цей код і він вам здасться очевидним і простим, не страшніше ніж строчка "ИТОГО" в інвентарній книзі(в дитинстві, коли я не знав значення цього слова, воно мене лякало своєю неминучістю і загадкосвістю).

Отже, ще раз з"ясуємо основні моменти. Джаваскрипт - це аж ніяк не конкурент ХТМЛу і ЦССу, а скоріше доповнення. Він має зовсім відмінний від них принцип дії.
В той час, як ЦСС і ХТМЛ є |декларативними| мовами, в яких ми пишемо "ЩО МИ ХОТІЛИ Б БАЧИТИ"(div там або ul), то джаваскрипт(а також ініш популярні мови C, C++, Java, PHP) є |імперативною| мовою, в якій ми пишемо, "ЩО І ЯК РОБИТИ".

Джаваскрипт можна вставити на сторінку дуже просто - за допомогою тега &ltscript&gt;
```
<div class="something"></div>
<script>
	document.getElementsByClassName('something')[0].innerHTML = 'Hello, world!';
</script>
```

Ось так виглядає шматочок джс-тексту, вбудованого у ХТМЛ сторінку. 
Все, що лежить усередині тегу script, не буде показане на сторінці, натомість, воно буде ВИКОНАНЕ браузером.
В даному випадку, цей код означає таке: "пошукати на сторінці теги із класом "something", вибрати перший з них, і всередину нього запхати текст "Hello, world!"
Кожного разу, при завантаженні сторінки, цей код буде виконаний один раз.
Для виконання наших завдань ви можете узяти будь-яку ХТМЛ сторінку, вставити туди тег script, і писати у ньому код. Після кожної можифікації коду потрібно заново відкрити сторінку(оновити її).

# Змінні



Увесь Джаваскрипт, по суті, складається з двох речей: із змінних і функцій. Змінні зберігають у собі дані, а функції їх обробляють, модифіковують і щось роблять.
Все, більше нічого у джаваскрипті нема. Для початку розберемось із змінними.
```
var name = 'John'; // я змінна!
var surname = 'Petrenko';
var age = 42;
```
name, surname, age - це змінні!
У першої змінної |ім"я| - name, а |значення| - John.
У перших двох змінних значення - це слова, а у третьої змінної - число.
Ось які важливі правила ви можете дізнатись із цього прикладу:<ul>
	<li>
		кожна дія в джаваскрипт пишеться з нової строчки
	</li>
	<li>
		після кожної дії ми повинні ставити крапку з комою(але є винятки)
	</li>
	<li>
		коли ми вперше використовуємо змінну, ми повинні писати ключове слово |var|(від англійського |variable| - змінна)
	</li>
	<li>
		Якщо ми хочемо записати у змінну слово або кілька слів - ми беремо їх у лапки. Числа у лапки можна не брати.
	</li>
	</ul>
Приклади для запам"ятовування:
	^
var 12_friends_of_ocean = 'movie'; // назва змінної НЕ МОЖЕ починатись із ЦИФРИ!
var i_am_a_c**l_hac|-|er = 'Valyera'; // Не вживайте ніяких спецсимволів у назві змінної! 
//Тільки букви, цифри і нижнє підкреслювання!
var good_intentions = evil; // слова беруться в лапки!
var multiline = 'In faith, I do not love thee with mine eyes,
For they in thee a thousand errors note; ';
// строчка не може містити переноси каретки!
^
var my_current_job_52 = 'JS developer'; // цифри можуть стояти будь-де, тільки не на початку
var my_first_job = 'tractor driver';
var a1 = "42";// ми можемо брати числа у лапки, якщо хочеться
var x2 = 37.5; // а можемо і не брати! Краще НЕ брати
var multiline = 'In faith, I do not love thee with mine eyes,' + 
'For they in thee a thousand errors note; ';
// для того, щоб записати текст у кілька строчок, 
// використовуйте об"єднання строчок за допомогою оператора +
	^





Отже, ми навчились присвоювати змінним значення. Що робити далі?
Найпростіше - це просто вивести значення змінної. При чому, вивести не в документ(роботу із ХТМЛ ми розглянемо пізніше), а просто в консоль.
Консоль необхідна програмісту для відлагоджування програми, в неї можна щось виводити, що не зачепить сам ХТМЛ документ, але допоможе нам зрозуміти, що відбувається у нас в коді.
У вашій панелі відлагоджування відкрийте вкладку "Console", там буде чистий лист. Спробуйте виконати у себе в документі(в тезі script, ви ж пам"ятаєте?) наступний код:

```
var answer = 42;
console.log(answer);
```
Ви побачите, що у вашій консолі вивелось значення змінної "answer" - 42.
В подальшому, якщо я казатиму "подивіться значення змінної", це означатиме - виведіть її в консоль.

```
var a = 42 * 3; // 126
```
Подвійні рисочки означають коментар! Часто ми писатимемо те значення, яке буде у змінної, в коментарі, якщо воно не очевидне.

# Операції зі змінними

Отже, поки що ми вміємо присвоювати змінним якесь значення, і виводити його в консоль.
А що ж ми можемо зробити зі змінними більш толкового?
З числами ми можемо робити арифметичні операції:

```
var length = 10;
var height = 3;

var area = length * height;// 30

// Ми можемо множити їх, ділити і віднімати!
var x = length - 20; // -10
// Для комплексних підрахунків, використовуйте дужки, так само, як і в математиці!
var a = ((length - height + 1)/2)*10; // 40
//спочатку віднімемо, потім додамо, потім поділимо, потім помножимо
```

Ок, це добре, а як бути зі словами?

```

var name = 'Ivan';
var surname = 'Kychatyi';

var fullname = name + surname;
```

2 + 12 буде 14, а скільки ж буде Ivan + Kychatui? Правильно, IvanKychatui!
Тобто, змінні, які містять слова, при додаванні - просто "склеюються разом"!
Це дуже зручно і часто використовується, наприклад, при генеруванні ХТМЛу(так, джаваскрипт таким займається!)
У нашому прикладі, щоб повне ім"я виглядало гарно, йому не вистачає якогось префіксу, а також пробілу між іменем і прізвищем.
Спробуємо додати його. Просто потрібно "склеїти" разом змінні і інші "слова".

```

var fullname = 'Mr. ' + name + ' ' + surname; // 'Mr. Ivan Kychatui'
```
Слова у джаваскрипті прийнято називати строчками.
Будь-який набір символів, окрім числа - це строчка.
Наприклад, 'wgfwe98yug8 t345345 124214124' - це строчка, "Peter's pecker picked another pickle bearing pussy pepper" - це теж строчка!
Строчки |обов"язково| беруться в лапки.

Ось ви і зрозуміли, чому потрібно відрізняти числа від слів.
Подивіться наступний ключовий приклад:

```
var Ivan_has_apples = 3;
var Mary_has_apples = 5;
var total_number_of_apples = Ivan_has_apples + Mary_has_apples; // 8

// а якщо ви спробуєте скласти строчки як числа
var Ivan_has_apples = '3';
var Mary_has_apples = '5';
var total_number_of_apples = Ivan_has_apples + Mary_has_apples; // 35!

// яблук насправді дещо менше
```
А все тому, що у другому випадку ви спробували скласти СТРОЧКУ 3 зі СТРОЧКОЮ 5, на що справедливо отримали результат - 35!


Так що поки що запам"ятайте, що змінні бувають двох типів: строчки і числа, і змішувати їх не варто(або робити це обережно)

Як ви помітили, інколи в змінну записується результат роботи над іншою змінною. А чи буде працювати така конструкція?

```

var a = 35;

a = a + 10;
```
Тут є кілька коментів, що можуть викликати ваш подив. 
По-перше, чому я в другій строчці не написав var? Тому що, коли ми згадуємо змінну удруге(і всі подальші рази), писати var не треба!
Добре, а як же ми так беремо... і записуємо в змінну а саму себе? Хіба це можливо?

Звісно, якщо розглядати цей запис з точки зору математики, це нонсенс. Рівняння виду x = x + 1 не має коренів, адже немає такого числа, яке було б рівне самому собі плюс одиниця)
Але це не математика. Цей вираз потрібно читати так:
"Запишіть будь-ласка у змінну "а" її поточне значення, до якого додали десять"
Отже, коли ми у правій частині пишемо якийсь вираз, вираховуєтсья його значення, а потім воно записується у ліву частину!


Ви можете спитати, а що ж відбувається із попереднім значенням? Відповідаю: воно зникає.
Ми записуємо "поверх" існуючого значення. Це може здатись дивним з точки зору побуту, т.к., до прикладу, ви не можете налити у банку з водою молока, перш ніж ви не виллєте звідти воду.
Однак у світі інформатики все дещо простіше. Розглянемо такий приклад

```
var my_beloved = 'Oksana';

// багато води утекло з тих пір...
my_beloved = 'Iryna';

// раптово!
```
Час проходить, і деякі речі змінюються. Звісно, реальна Оксана нікуди не ділася, просто місце у вашій душі, яке було зайняте нею, тепер займає інша дівчина.
Так і зі змінними: нове значення заміщує старе, і старе просто припиняє існувати, що, однак, не значить, що об"єкт, який воно означало, теж зник.

Одне дуже важливе правило: змінні можна використовувати тільки |після| того, як ви їх оголосили.

^
// синтаксична помилка, ви не взяли строчку в лапки
var a = Mike;

// ще одна помилка, ви використовуєте різні типи лапок в одній строчці
var b = 'I feel good!";

// 'типова помилка: лапки всередині строчки сприймаються як її завершення!
// Такий запис призведе до помилки! Джаваскрипт подумає, що строчка - це "Hi, what", 
// (ви ж обмежили її одинарними лапками), а далі іде вже... незрозуміло що!
var q = 'Hi, what's going on?';

//'ви пробуєте використати змінну |y| |до| її оголошення! Це призведе до помилки
var x = 10;
var sum = x + y;
var y = 13;

^

// строчки пишуться тільки в лапках!
var a = 'Mike';

// одинарних або подвійних!
var b = "Josh";

// якщо в самій строчці використовуються одинарні лапки, обгорніть її в подвійні, і навпаки!
var q = "Hi, what's going on?";

^
Окрім простого додавання, у джаваскрипті є також окрема операція, яка збільшує число на одиницю(називається інкремент).
```
var a = 35;
++a;
console.log(a); //36
console.log(++a); //37
```
Поки що вам не ясно, для чого знадобився короткий запис для такої операції, але потім побачите, що він нам часом дуже спростить життя.


Завдання для засвоєння.
Починаємо ліпити пасочки.

```
var a = 23;
var b = 44;

// Напишіть таку змінну "c", яка була б подвоєною сумою змінних "a" i "b"

???%c == 134%var c = a + b;%
```
Це пробний приклад. Щоб отримати правильну відповідь, введіть "var c = (a + b)*2;" і натисніть "Перевірити!"

А ось ще завдання

```
var name = 'John';
var surname = 'Doe';

// Створіть змінну fullname, яка б була результатом складення 
// змінної name, пробіла і змінної surname, тобто, 'John Doe'

???%fullname == "John Doe"%var fullname = name + ' ' + surname;%
```
```
// "Загорніть" текст змінної в тег div
var str = "Johnny got his gun"; 

// var wrapped = ???; 

???%wrapped == '<div>Johnny got his gun</div>'%var wrapped = '<div>' + str + '</div>'%

// console.log(wrapped); // <div>Johnny got his gun</div>
```

```
// нехай змінна tag є тегом, в який треба загорнути строчку, а str - сама строчка.
var tag = 'b';

var str = 'Hello, Dolly!';
???%wrapped == '<b>Hello, Dolly!</b>'%var wrapped = '<' + tag + '>' + str + '</' + tag + '>'%
//console.log(wrapped); // <b>Hello, Dolly!</b>
```
Вітаю, ви дещо знаєте про змінні! :)

@@@

@@@

## Функції

Це сама сіль джаваскрипта. Якщо змінні потрібні для того, щоб зберігати дані, то функції покликані |щось із ними робити|.
Вони бувають двох типів: стандартні, які входять у базовий джентльменський набір можливостей джаваскрипта, і самописні, які ви створюєте самі для вирішення своїх потреб.

# Стандартні функції

Стандартні функції джаваскрипта дозволяють нам зробити ті речі, які ми самі нізащо не змогли б зробити, використовуючи лише змінні і відомі нам операції над ними.
Наприклад, вивести юзеру в браузер повідомлення про щось. 
```
var user = 'Sasha';
var greeting = 'Hello, Mr. ' + Sasha;

alert(greeting);  // <-ось це функція!

```
Тут alert(...) - це |виклик| функції. Кожна функція може викликатись будь-яку кількість разів, в будь-якому місці.
Те, що знаходиться в дужках - це |аргументи| функції. Функція alert() виводить якесь повідомлення на екран. Але ж ми повинні вказати, яке!
Ось для цього існують аргументи функції. Аргументи - це якісь дані, частіше за все змінні, які ми |передаємо| в функцію при її виклику.
Як бачите, кожна функція має ім"я, по якому її можна викликати.
Для того, щоб викликати функцію, треба написати її ім"я, відкрити дужки, написати там її аргументи, і закрити дужки :)

^
// змінна ololo не існує(ми її не оголосили)
alert(ololo); 

alert(msg);
var msg = 'Hello, long distance runner!';
// теж неправильно, змінна повинна бути оголошена |ДО| того, як її використають(вище)

// ми не передали жодного аргументу, це не є добре)
alert();

^

var ololo = 'Iona';
alert(ololo);

// так теж можна - передавати в якості аргументів строчки!
alert('Hello, Dolly!');

// і навіть комбінувати строчки зі змінними прямо в аргументах функції!
var name = 'Mike';
alert('Hello, ' + name + '!');

^

Однак, є і інший різновид стандартних функцій, які викликаються дещо інакше.

# Методи

```

var a = 'Hello, my name is John!';

var b = a.replace("John", 'Petro'); // 'Hello, my name is Petro!'

```

Такі фунції викликаються якби "від змінної". Ви пишете ім"я змінної, ставите крапку, і далі пишете ту функцію, яку хотіли б до неї застосувати!

```
var a = 'I am A CaMeL';

a = a.toLowerCase();// 'i am a camel'

```

Давайте тепер роздивимось, що це за функції і як з ними поводитись.
Вище були згадані дві функції, replace() і toLowerCase(). Перша функція, як ви здогадались, замінює в строчці задані слова іншими.
Друга функція робить усі букви у строчці - прописними, тобто, у нижньому регістрі.

Ці функції відносяться до групи т.зв. строкових функцій, тобто функцій, які призначені для роботи зі строчками.
Вони викликаються "від змінної", тобто, через крапку після імені змінної.
Функція replace() має два аргументи - перший означає "шо шукати", а другий - "на що замінити знайдені строчки".

Функція toLowerCase() не має аргументів взагалі. Ви можете спитати, а як вона дізнається, з якою строчкою їй працювати?
Справа в тому, що передавати вихідну строчку немає потреби, так як нею є та строчка, "від якої" ми викликаємо функцію.
В даному випадку, змінна "а". У цьому і весь сенс виклику "від змінної": він якби по замовчуванню використовує ту змінну, від якої ми виликаємо.
Такі функції у джаваскрипті називаються |"методами"|(це важливий термін, запам"ятайте його).

^
// безглуздий запис - ми викликаємо функцію, але нікуди не записуємо результат! 
// Змінна str залишиться такою ж
var str = 'Donatas Banionis';
str.replace("s", "");
console.log(str); // 'Donatas Banionis', те саме

^

var str = 'Donatas Banionis';
str = str.replace("s", "");
console.log(str);// 'Donata Banionis'

^ 
Ми замінили літеру "s" на пусту строчку, тобто, фактично - вирізали її. Зверніть увагу, метод replace() замінює лише перше входження шуканої строчки!
Виклик методу не впливає на ту змінну, від якої ми його викликали.
Для того, щоб змінити значення змінної, його треба в неї записати.

```

var fruits = 'bananas, apples, carrots';

// carrots?!
var real_fruits = fruits.replace("carrot", "apricot");

console.log(real_fruits); // 'bananas, apples, apricots'
console.log(fruits); // 'bananas, apples, carrots' - без змін, як і очікувалось!

```
Джаваскрипт має багато стандартних функцій і методів для роботи зі строчками і числами, повний перелік ви можете знайти в інтернеті)
Ми будемо поступово знайомитися із деякими з них.


# Самописні функції

Нарешті, ви можете створювати функції самі!
Це відбувається у два етапи: 

а) ви описуєте функцію

б) користуєтесь нею!

При чому, другий етап вам вже відомий - самописними функціями користуються так само, як і стандартними.
А от як описати функцію?
Для цього є певний синтаксис. Коли ви зустрічаєте слово "синтаксис" в цьому підручнику, це означає, що зараз буде приклад, в якому треба звертати увагу
на найменші дрібниці і нюанси, і свято дотримуватись їх, інакше ваш код не запрацює.
Вам вже відомий синтаксис оголошення змінних(слово var), синтаксис операцій(знак дорівнює і крапка з комою в кінці), і ви вже знаєте, як викликати функції(написати ім"я функції і в дужках аргументи).

Тепер ви повинні запам"ятати синтаксис |оголошення| функції.

```

var get_square = function(num){
	return num * num;
}

// функція get_square буде повертати квадрат числа, тобто, число, помножене само на себе
var a = 3;
var b = get_square(a); // 9

// ще приклад
// функція повертає строчку, загорнуту в заданий тег.
var wrap_in_tag = function(str, tagname){
	var wrapped = '<' + tagname + '>' + str + '</' + tagname + '>';
	return wrapped;
}

var a = 'span';
var g = 'Hello, I love you, could you tell me your name';

var html = wrap_in_tag(g, a);

html; // <span>Hello, I love you, could you tell me your name</span>

```

Тут уже є багато над чим помедитувати.
Для початку, розберемось із синтаксисом, тобто, як треба правильно розставляти фігурні дужки і коми, щоб у вас усе працювало.

По-перше, зверніть увагу, що оголошення функції подібне до створення змінної - ліва частина у них однакова.
Ми пишемо ключове слово "var" і назву функції, яку ми хотіли б їй дати. А ось права частина специфічна.
Ми пишемо ключове слово function, потім відкриваємо дужки, перераховуємо список аргументів, закриваємо дужки, відкриваємо фігурні дужки, пишемо |тіло функції|, і закриваємо дужки.
Ми можемо не написати жодного аргументу, тіло може бути пустим, але ключове слово function, дужки і фігурні дужки ви зобов"язані написати!

```
var stupid = function(){}; // це цілком правильний запис! 
// Щоправда, толку від такої функції небагато

```

# Як працюють функції. Оголошення і передача аргументів

Але як це працює? Чому ми у функції wrap_in_tag назвали аргументи str i tagname, а передали туди змінні g i a, як це працює?
Ось ще один приклад для медитації.

```
var he = 'John';
var she = 'Mary';

var merry = function(bride, groom){
	return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}

var happy_message = merry(she, he);

```

В реальному житті функції можна порівняти із обрядами, церемоніями, взагалі, будь-якими процесами.
Як би ви описали інопланетянину, що таке весілля і як воно відбувається?
По-перше, визначимось із мінімальними вимогами. Для весілля потрібно щонайменше двоє людей, наречений і наречена(по можливості, різної статі).
Звичайно, там може бути присутнім багато людей, але справді значущі зміни відбуваються, перш за все, саме у житті цих двох людей.
Отже, нам потрібні двоє. 
Далі, ми опишемо, як це зазвичай відбувається. Наречені вінчаються у церкві, далі реєструють шлюб у загсі, наречений одягає обручку
на палець нареченої, і так далі. 

Насправді, нам не дуже цікаві деталі. Важливий сам підхід, як це описується.
Ми описуємо процес абстрактного весілля(абстрактне весілля, чудово, чи не так? ви вже відчуваєте дух програмування, який витає у таких фразах?), 
те, як воно взагалі відбувається, а не розповідаємо історію чийогось конкретно весілля.
Учасників процесу(весілля) ми називаємо згідно їх ролей(наречений і наречена). 
Коли ми просто описуємо цей обряд, невідомо, чи будуть це Іван і Марія, чи Петро і Ганна, нам це неважливо, ми говоримо "взагалі".


Будь-яке твердження із нашої повсякденної мови може бути віднесене або до абстрактних, або до конкретних.
Наприклад, "Лошади кушают овес и сено, Волга впадает в Каспийское море". Перша частина - абстрактна, т.як ми говоримо про усіх коней узагалі, маючи на увазі якусь всесвітню закономірність.
А друга - це конкретне твердження, т.як мова іде про певну річку(Волгу) і те, що вона робить. 

Будь-який процес має абстрактний формальний опис(як це взагалі робиться), і має конкретні випадки реального свого застосування.
Так ось, це саме те, що ми робимо із функціями! Подивіться ще раз:
```
var merry = function(bride, groom){
	return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}
```
Ми описали абстрактну функцію "одружитися", яка приймає два аргументи(наречену і нареченого), і щось робить(в даному випадку, просто формує привітання для них).
Поки що ніхто ні з ким не одружується насправді, ми лише описуємо процес одруження, як воно має відбуватись.
У програмуванні це називається - ми оголосили функцію.
А вже після оголошення, ми можемо її застосовувати! Тобто, женити конкретних іванів і марійок!

```
var he = 'John';
var she = 'Mary';
var happy_message = merry(she, he);

```
Це - застосування функції, або, як кажуть у програмуванні - виклик. 
Функція merry була викликана, при цьому їй були передані змінні she(в якості аргумента bride) і he(в якості аргумента groom).
Результат роботи функції(строчка) був записаний у змінну happy_message. 

Тут є ще один момент, який необхідно пояснити. У програмуванні функції потрібні, перш за все, для того, щоб проводити обчислення.
Тобто, пілся виконання, функція повинна повернути якийсь результат. Але що буде слугувати результатом функції?
Для цього нам потрібне ключове слово return.
Коли ми пишемо return, це означає: повернути те, що стоїть після return, в якості результата роботи функції, і припинити її подальше виконання.

Зверніть увагу! Функції мають спільний простір імен із змінними!

^

var add_respect = function(sir_name){
	var respectful_name = 'Sir ' + sir_name;
}
console.log(add_respect('John Doe')); // пусто!

// Неправильно, змінна respectful_name буде обчислена, але функція поверне порожній результат!

var foo = 'bar';

var foo = function(str){
	return '<b>' + '</b>';
}

foo(foo);
// нонсенс! може бути тільки одна змінна або функцію з цим іменем! 
// В даному випадку, під іменем foo буде лежати функція, бо вона оголошена пізніше!
var add_respect = function(sir_name){
	return 'Sir ' + sir_name;
	console.log("I'm stupid!"); // невірно, ця строчка ніколи не виконається, т.як після слова return функція припиняє роботу і повертає результат
}
^

var add_respect = function(sir_name){
	var respectful_name = 'Sir ' + sir_name;
	console.log('name is', respectful_name);
	return respectful_name;
}
console.log(add_respect('John Doe')); // Sir John Doe

^
Напишіть функцію wrap_h2, яка повертає передану їй строчку, обрамлену в тег h2
```
var str = 'Fireball';

???3%wrap_h2('a') == '<h2>a</h2>'%var wrap_h2 = function(a){ 
	return '<h2>' + a + '</h2>';
}%
//var wrapped = wrap_h2(str);
//console.log(wrapped); // <h2>Fireball</h2>
```
Напишіть функцію round_area(), яка рахує площу кола по переданому їй |діаметру|(вважаючи, що число Пі дорівнює 3.14).
```
???5%round_area(10) == '78.5'%var round_area = function(diameter){
	var radius = diameter/2;
	var area = 3.14*radius*radius;
	return area;
} %

// round_area(10); // 78.5
```
Завдання на додатковий бал: напишіть функцію wrap_in_tag(str, tag), яка повертає строчку, загорнуту в тег, а також функцію wrap_in_div, яка, |використовуючи першу функцію|, загортає строчку в тег div.
```

var str = '2TE10M';
???10%wrap_in_tag('a', 'b') == '<b>a</b>' && wrap_in_div('a') == '<div>a</div>'%
	var wrap_in_tag = function(str, tag){
		var new_str = '<' + tag + '>' + str + '</' + tag + '>';
		return new_str;
	}
	var wrap_in_div = function(str){
		var new_str = wrap_in_tag(str, 'div');
		return new_str;
	}
%
```

Цей приклад настільки важливий, що розберемо його детально.
Ось правильне рішення попередньої задачі:
```
var wrap_in_tag = function(str, tag){
	var new_str = '<' + tag + '>' + str + '</' + tag + '>';
	return new_str;
}

var wrap_in_div = function(str){
	var new_str = wrap_in_tag(str, 'div');
	return new_str;
}

```
Звичайно, ми могли б написати функцію wrap_in_div простіше, 
приблизно так:

```
var wrap_in_div = function(str){
	var new_str = '<div>' + str + '</div>';
	return new_str;
}
```
Але для чого нам заново переписувати усю логіку формування строчки?
У нас же є чудова універсальна функція wrap_in_tag(), отже, ми використаємо її!
Таким чином, ви бачите, що функції можна використовувати одна в одній, і це прекрасно.
Процес розробки програмного забезпечення, грубо кажучи, полягає в написанні спочатку простіших функцій, на основі яких пишуть складніші і специфічніші функції, які реалізовують поставлені задачі.

# Область видимості змінних
Що таке область видимості змінних? Про що йде мова?
Ну, ви вже знаєте, що, наприклад, не можна використовувати змінну раніше, ніж вона оголошена.
```
alert(a); // буде помилка, змінної "а" ще нема
var a = 'Hello!';
```
Тобто, ви вже розумієте, що змінні не можна використовувати де завгодно.
А як бути зі змінними, оголошеними в функції?
```
var fill = function(str){
	var template = '<a>$$$</a>';
	return template.replace("$$$", str);
}
// функція підставляє ваші дані в шаблон
var str = fill('Google'); // '<a>Google</a>'
// а чи доступна нам змінна template, оголошена в функції?
console.log(template);
// Hi!
```
Ні, змінні, оголошені всередині функцій, існують самі по собі, і ніяк не перетинаються із зовнішніми змінними!
А чи можна із функції звернутись до зовнішньої змінної? Так!
Наприклад, ось функція, яка кожен раз буде повертати число, на один більше за попереднє.
^
var get_num = function(){
	var counter = 0;
	return ++counter;
}

get_num(); // 1
get_num(); // 1 :(
get_num(); // 1 :'(...
^
var counter = 0;
var get_num = function(){
	return ++counter;
}

get_num(); // 1
get_num(); // 2 :)
get_num(); // 3 :D fuck yeah!
^
Чому перший приклад неправильний?
Змінна counter буде створюватися кожного разу при запуску функції! І кожного разу вона буде дорівнювати нулю, а потім одиниці!
Кожного разу при запуску функції ця історія буде повторюватися, як у фільмі "День Бабака". Не допускайте такої печалі зі своїми функціями!
Натомість, друга функція звертається до зовнішньої змінної counter.
Ця змінна зберігає своє значення незалежно від функції. Функція лише збільшує його кожного разу на одиницю і повертає!

<div class="quote" style="display:none;">
	 Когда-то я был лагерным надзирателем. Возил заключенных в таком же металлическом фургоне. Машина называлась - автозак. В ней помимо общего "салона" имелись два тесных железных шкафа. Их называли стаканами. Там, упираясь в стены локтями и коленями, мог поместиться один человек. Конвой находился снаружи. В железной двери была проделана узкая смотровая щель. Заключенные называли это устройство: "Я тебя вижу, ты меня - нет". Я вдруг почувствовал, как это неуютно - ехать в железном стакане. А ведь прошло шестнадцать лет...

	 С.Довлатов. "Компромисс"
</div>

Отже, із змінними у функціях запам"ятатйте цей принцип: "я тебе бачу, ти мене ні": всередині функцій ми можемо звертатись і до зовнішніх змінних, і до внутрішніх, а ззовні 
добратися до змінних із функцій ми не можемо!
```
var site_domain = 'example.com';

// напишіть функцію get_link(str), яка повертає повний лінк на підрозділ сайту str
// get_link('blog.php') -> 'http://example.com/blog.php'
// доменна адреса має братись із змінної site_domain
???3% get_link('a') == 'http://example.com/a'%
var get_link = function(str){
	return 'http://' + site_domain + '/' + str;
}
 %
```
@@@
@@@
## Гілкування

Джаваскрипт і подібні мови називають також мовами сценаріїв, і це досить влучна назва.
Програма, написана на Джаваскрипті, описує, як будуть розгортатися події на підмостках браузера, що буде показано юзеру що буде робитись із ХТМЛ сторінкою.
Цю паралель можна розвивати і далі, але є дуже суттєва відмінність між програмуванням і театральним сценарієм.
На відміну від театру, де Отелло буде убивати Дездемону кожного разу, скільки буде ставитись п"єса, програмам властива деяка гнучкість, інтерактивність.

Досі все, що ми писали, було простою послідовністю дій: візьми те, запиши туди те, запусти функцію таку. Тобто, наша програма кожного разу працювала б 
по одній і тій же схемі. Однак це не цікаво! На допомогу нам приходить механізм розгалуження, гілкування. 
Гілкування працює так: ми перевіряємо якусь умову, якщо вона вірна - робимо одне, якщо не вірна - робимо інше.
"Якщо це |так|, то зроби це. Якщо це |НЕ так|, то зроби щось інше"

```
var Desdemona_is_guilty = false;

if(Desdemona_is_guilty){ // <- початок гілкування. Ключове слово if, умова Desdemona_is_guilty
	kill('Desdemona');
} else {
	kill('Iago');
}
```
Поки що не заглиблюємось у нюанси, загальна суть того, що відбувається, приблизно зрозуміла.
Припустимо, нам треба написати функцію, яка поверне із двох чисел те, котре найбільше. Ось її реалізація.
```
var get_max = function(a, b){
	if(a > b) {
		return a;
	} else {
		return b;
	}
}

get_max(20, 13); // 20
get_max(1, 2); // 2

```

Давайте тепер розберемось в синтаксисі.
Перше, що ви повинні побачити і запам"ятати - це ключове слово if. З нього починається розгалуження.
В дужках після if ми пишемо те, що ми хочемо перевірити. Наприклад, чи одне число більше за інше.
Після цього ми відкриваємо фігурні дужки, і пишемо те, що виконається, якщо написана нами умова вірна.
Потім ми закриваємо їх, і можемо написати ще одне ключове слово, else, і після нього той код, який виконається, якщо умова НЕ вірна.

Зверніть увагу, що та умова, яку ми пишемо, завжди має лише два варіанти: так або ні, істина або брехня.
Наприклад, " if(вона вагітна) { ...робимо щось одне... } else { ...робимо щось інше... }
Проміжних варіантів не може бути, або вагітна, або ні.

У фігурних дужках ми можемо писати будь-який код: оголошувати змінні, викликати функції, все що завгодно, у т.ч. ще одне гілкування.
Це логічно, адже сам набір дій у тому чи іншому разі може бути яким завгодно. Важливе питання - як ми можемо формулювати умови.

# Перевірка умов

Отже, питання полягає у тому, як ставити питання :)
Давайте придивимось до звичайних побутових формулювань:
"Піди у магазин, купи яєць, а якщо їх не буде, то візьми літр молока".
Якщо перекласти це речення на суху мову програмування, це звучатиме так:
"Піди у магазин. Перевір, чи є там в наявності яйця. Якщо є, то - купи яйця. Якщо ні, то - купи молоко".
Тут ми бачимо усі складові гілкування: умова(є в наявності яйця), план А(якщо яйця є, то купуємо їх), план Б(купуємо молоко).
Ще сухіше:
```
go_to_shop();
if(eggs_available()){
    buy('eggs');
} else {
    buy('milk');
}
```
Крім перевірки на наявність/відсутність чого, можуть бути чисто математичні порівняння, які можна робити ЛИШЕ з числами: більше, менше, більше або дорівнює, менше або дорівнює.
Ось так:
```
if(a > b){ ... } else { ... }
if(a < b){ ... } else { ... }
if(a <= b){ ... } else { ... } // менше або дорівнює
if(a >= b){ ... } else { ... } // більше або дорівнює
if(a == b) { ... } else { ... } // а дорівнює b
if(a != b) { ... } else { ... } // а НЕ дорівнює b
```
^
// неправильний запис оператора "менше або дорівнює"
if(a =< 3){ ... } else { ... }
^
// а отак правильно!
var a = 2;
if(a <= 3){ ... } else { ... } // а отак правильно!
^
Існує також помилка, настільки розповсюджена, що її хочеться розібрати окремо.
Це ситуація, коли замість перевірки на рівність, яка здійснюється оператором "==", змінну присвоюють оператором "=".
Між ними величезна різниця!

^
// Увага, помилка! Замість перевірки на рівність ми ПРИСВОЇМО значення b в а
if(a = b) { ... цей код буде виконуватись майже завжди, бо ми просто запишемо b в а ...} else { ... }
^
// Правильний варіант порівняння двох змінних
if(a == b) { ... } else { ... }
^
Звичайно, інтуїтивно хочеться записати якраз if(a = b), т.як це більш логічно і звично після математичних рівнянь.
Найбільша проблема, що ніякої помилки при цьому не виникне, джаваскрипт виконається нормально, адже сам по собі цей запис є валідним(дійсним, можливим).
Так що, якщо ви одразу не напишете цю перевірку правильно, ви прирікаєте себе на довгі муки в пошуках джерела помилки.

Давайте розберемось, як правильно використовувати гілкування.
Припустимо, нам треба написати функцію, яка пише вітання для юзера в залежності від його статі.
У функцію буде передаватись ім"я юзера, а також стать, а повертати ми будемо строчку із привітанням.
Ця функція, на відміну від попередніх, буде трішки дискримінуючою, тобто, вона буде себе вести по-різному, маючи справу з чоловіками і жінками.

```
var get_sexist_greeting = function(name, gender){ ... }

get_sexist_greeting('John', 'male'); // Hello, mr. John!
get_sexist_greeting('Mary', 'female'); // Hello, ms. Mary!

```
Вочевидь, в функції нам треба буде формувати результат по-різному, в залежності від статі.
Рішення "в лоб" буде виглядати приблизно так:
```
var get_sexist_greeting(name, gender){
	if(gender == 'male'){
		var greet = 'Hello, mr.' + name + '!';
		return greet;
	} else { // females, transgenders and other non-males
		var greet = 'Hello, ms.' + name + '!';
		return greet;
	}
}

``` 
Така функція, в принципі, буде працювати, однак, її можна трішки "покращити"(в хорошому розумінні цього слова).
Гарний програміст старається не писати зайвого коду.
Якщо ми подивимось на цю функцію, можна помітити, що результат відрізняється лише на одну букву.
Більшу частину строчки можна зробити спільною, і варіювати лише невелику частинку, яка є звертанням.
```
var get_sexist_greeting(name, gender){
	if(gender == 'male'){
		var address = 'mr.';
	} else { // females, transgenders and other non-males
		var address = 'ms.';
	}
	var greet = 'Hello, ' + address + ' ' + name + '!';
	return greet;
}
```
Ось так вже значно краще! Ми ввели додаткову змінну, яка позначає частинку звертання і варіюється в залежності від статі, а інша частина строчки залишається спільною для всіх.
Так ми трохи скоротили функцію і зробили її яснішою, читабельнішою.
Вітаю, тепер ви знаєте що таке рефакторинг. Цей термін у програмуванні позначає процес покращення якості коду без зміни результатів його діяльності.

Звичайно, на перших порах вам буде не до якості коду, ви будете старатись написати функції як-небудь, аби тільки вони давали бажаний результат.
Однак, з часом, ваша свідомість як програміста піднесеться на новий рівень, і ви будете піклуватись не тільки про працездатність коду, а і про його читабельність, підтримуваність і красу(така собі піраміда Маслоу духовних потреб програміста ).
В нашій книзі я інколи заоохочуватиму вас до написання якісного коду.
```
// Напишіть функцію get_over_10(), яка приймає число, і повертає його, 
// якщо воно більше 10, а якщо воно менше, то повертає 10.
???4%get_over_10(2) == 10 && get_over_10(23) == 23%
var get_over_10 = function(num){
    var res = num;
    if(num < 10){
        res = 10;
    }
    return res;
}
%
```

```
// Напишіть функцію get_first_positive(), яка повертає перший із трьох аргументів, 
// який буде більше за 0
// Якщо жодне із значень не буде додатнім, поверніть 0
???4%get_first_positive(-1, 2, 12) == 2 && get_first_positive(-1, -2, 12) == 12 && get_first_positive(-1, -2, -12) == 0%
    var get_first_positive = function(a, b, c){
        var res = 0;
        if(c > 0){
            res = c;
        }
        if(b > 0){
            res = b;
        }
        if(a > 0){
            res = a;
        }
        return res;
    }
%
```
# Логічний тип даних

Дотепер ми знали два типи даних: число і строчка. Зараз ви познайомитесь зі ще одним типом даних - логічним.
Кожен тип даних характеризується можливим діапазоном значень.
Давайте згадаємо, які у нас бувають строчки і числа

```
// Строчки
var a = 'Hey, Joe!';
var b = 'I wonder, ' +
'Where you going with that gun in your hand?';
var c = "23"; // це теж строчка, не забувайте
var d = 'Number Pi is ' + 3.14; // якщо ми об"єднуємо число і строчку, виходить строчка

// Числа
var x = 13;
var pi = 3.14;
var dead = -1;
var sum = x + dead;
```
А які можуть бути значення у "логічного типу даних"?
```
var she_is_pregnant = false;
// ... щось відбулося ...
she_is_pregnant = true;
```
Усього два значення - true i false! Чорне і біле, правда і брехня. Дуже просто запам"ятати.
Пишуться вони як строчки, тільки без лапок.
```
var a1 = 'true'; // string
var a2 = true;

var b = a1.replace('ru', 'ua'); // tuae
var c = a2.replace('ru', 'ua'); // ERROR! Метод replace є тільки у строчок!
```
Для чого потрібні такі змінні? Для використання у перевірці умов!
Згадайте, що ми пишемо в дужках після if:
```
if(a > b) { ... } else { ... };

if(my_age > 18) { 
	// sell me some cigars, now!
} else {
	// please, don't tell my mom!
};

```
Якщо ми пишемо 2 + 3, яке значення має цей вираз? Правильно, 5.
А якщо ми пишемо 5 < 2, то яке значення буде у цього виразу? Звісно, false!
Кожен раз, коли ми пишемо щось у дужках після if, цей вираз обчислюється, і ми дивимось, істинний він чи ні.
Подивимось ще раз на приклад з початку розділу, тепер він буде вам зрозумілий.
```
var Desdemona_is_guilty = false;

if(Desdemona_is_guilty){
	kill('Desdemona');
} else {
	kill('Iago');
}
```
Ось тут, на щастя, буде убитий Яго, а не невинна Дездемона!
Ми присвоїли у змінну Desdemona_is_guilty значення false, отже, буде виконана друга частина гілкування, та, котра йде після else!

В if можна передавати не тільки змінні, а і складні конструкції, наприклад, виклики функцій.
Припустимо, хлопчик хоче придбати цигарок.
Ми будемо перевіряти за допомогою спеціальної функції, чи можна йому продати цигарки.

```
var we_can_sell_cigars = function(age){
	var permit = age >= 18; // у змінну permit попаде логічне значення, true або false!
	return permit;
}

var boy_age = 17;

if(we_can_sell_cigars(boy_age)){
	console.log('Fuck yeah!');
} else {
	console.log('Ok :(');
}
```
Що буде виведене в результаті? Звичайно, Ok :(
Ще раз подумаємо, що тут відбувається.
Ми перевіряємо, чи можна продати хлопцю цигарки. У нас є конструкція if, значить, перш за все, ми 
обчислюємо значення в дужках. У дужках у нас викликається функція we_can_sell_cigars, при чому їй передається вік хлопчика(17 років).

Всередині цієї функції ми приймаємо вік як аргумент age, і записуємо в змінну permit, чи не менший цей вік за 18.
В даному випадку, таки менший, отже, змінна permit буде дорівнювати false.
Ми повертаємо цю змінну як результат виконання функції we_can_sell_cigars в наш if, він бачить, що діла неважні(йому прийшло false), і розчаровує хлопчика,
направляючи його шляхом else.

# Кілька умов за раз

Нам треба написати функцію, яка б допомогла хлопцю розібратися, що з ним зараз відбувається.
З одного боку, ми будемо перевіряти, чи не вагітна його дівчина, а з іншого, чи кохає він її.
Результат(його поточний стан) буде таким:
а) якщо вагітна і він кохає її - 'happy'
б) якщо вагітна і НЕ кохає - 'in trouble'
в) якщо НЕ вагітна і кохає - теж 'happy'
г) якщо НЕ вагітна і НЕ кохає - 'OK'

Отже, як нам написати таку функцію?
В принципі, це не так складно, якщо розуміти, що гілкування може бути скільки завгодно вкладеним.

```
var check_state = function(pregnant, in_love){
	if(pregnant){
		if(in_love){
			var state = 'happy';
		} else {
			var state = 'in_trouble';
		}
	} else {
		if(in_love){
			var state = 'happy';
		} else {
			var state = 'OK';
		}
	}
	return state;
}
```
В принципі, працездатно, але ж так громіздко!
Глибокі рівні вкладеності погіршують читабельність.
```
var check_state = function(pregnant, in_love){
	if(pregnant && in_love){
		var state = 'happy';
	}
	if(pregnant && !in_love){
		var state = 'in_trouble';
	}
	if(!pregnant && in_love){
		var state = 'happy';
	}
	if(!pregnant && !in_love){
		var state = 'OK';
	}
	return state;	
}
```

Отак вже краще!
Отже, коли ми пишемо умову, ми можемо вживати ключове слово &&(називається "логічне І", читається як "and").
В результаті, значення всього виразу "pregnant && in_love" буде true, тільки якщо |і| pregnant, |i| in_love будуть true.
Якщо ж хоч одне щось із них буде false - весь вираз буде рівним false!

І ще цікава річ, яку ви, сподіваюсь помітили - знако оклику перед змінною. Він означає заперечення.
Тобто, !love означає НЕ love.
```
var guilty = true; // true
var guiltless = !guilty; // false
```
Отже, знак оклику перетворює логічну змінну на її протилежність.

Крім логічного AND(&&), є ще і логічне OR, яке записується як ||(дві палки). Воно допоможе нам покращити код.
Ми бачимо, що два випадки є аналогічними(дають один і той же результат - happy).
Отже, ми можемо об"єднати їх в один.

```
var check_state = function(pregnant, in_love){
	if((pregnant && in_love) || (!pregnant && in_love)){
		var state = 'happy';
	}
	if(pregnant && !in_love){
		var state = 'in_trouble';
	}
	if(!pregnant && !in_love){
		var state = 'OK';
	}
	return state;	
}
```
Уже одним кейсом менше! Як ви можете побачити, складова else не є обов"язковою!
Логічне OR дає true, якщо хоча б один із його складових є true.
Але ми можемо ще спростити нашу функцію!
Якщо придивитись, у першій умові не важливо, pregnant чи не pregnant, головне щоб in_love було true.

```
var check_state = function(pregnant, in_love){
	if(in_love){
		var state = 'happy';
	} else {
		if(pregnant){
			var state = 'in_trouble';
		} else {
			var state = 'OK';
		}
	}
	return state;	
}

```
Мене, чесно кажучи, напрягає писати по багату разів var, а якщо ще відвертіше казати, то це і взагалі неправильно.
Тому спробуємо оголосити змінну один раз на початку, присвоївши їй якесь значення по замовчуванню
```
var check_state = function(pregnant, in_love){
	var state = 'happy';
	if(!in_love){
		if(pregnant){
			state = 'in_trouble';
		} else {
			state = 'OK';
		}
	}
	return state;	
}
```
Ось це вже мені подобається!
var пишемо один раз. Тобто, змінна гарантовано оголошується на початку, а далі, в певних ситуаціях, може бути перезаписана.
Вітаю, ви ще раз попрактикувались у рефакторингу, і розібрались, як вправлятись із логічними запереченням(!), AND(&&) i OR(||).

@@@
@@@
## Об"єкти
Для чого потрібні об"єкти, можна легко зрозуміти, згадавши один із попередніх прикладів.
```
var he = 'John';
var she = 'Mary';
var merry = function(bride, groom){
	return 'Congratulations, ' + groom + ' and ' + bride + ', you are married!';
}
var happy_message = merry(she, he);
```
Ця функція працює непогано, але вона занадто проста. Зазвичай в житті все буває складніше, наприклад, працівники ЗАГСу, йомвірно, перевірять, чи є молодята різної статі,
або чи не є один із них уже одруженим на даний момент. Отже, як ми можемо в нашій функції запобігти багатоженству?
Що ж, ми можемо ввести додаткові логічні змінні, які будуть зберігати інформацію про поточний статус.
```
var person_1_name = 'Petro';
var person_1_status = 'unmarried';
var person_2_name = 'Mary';
var person_2_status = 'divorced';

var merry = function(name1, status1, name2, status2){
    if(status1 == 'married' OR status2 == 'married'){
        return 'Marriage failed, error code 400';
    }
	return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
```
Однак, це ще далеко не все. У нас в Україні одностатеві шлюби заборонені, тому ми ще маємо перевірити, щоб стать молодят відрізнялась!
```
var person_1_name = 'Petro';
var person_1_status = 'unmarried';
var person_1_gender = 'male';
var person_2_name = 'Mary';
var person_2_gender = 'female';

var merry = function(name1, status1, gender1, name2, status2, gender2){
    if(status1 == 'married' OR status2 == 'married'){
        return 'Marriage failed, error code 400';
    }
    if(person_1_gender == person_2_gender){
        return 'Homosexual marriages prohibited!';
    }
	return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
```
Вам вже страшно? Мені, особисто, так. 6 аргументів - це вже занадто!
На кожну людину нам треба завести по 3 змінні, що означають якісь її характеристики: ім"я, стать, шлюбний статус.
Але ж є ще прізвище, адреса, вік... Так ми заморимось створювати змінні :)

Ідея об"єктів полягає у тому, щоб згрупувати разом змінні, які позначають властивості одного і того самого предмета.
У вас бувала ситуація, коли весь робочий стіл завалений ярликами і файлами? Як ви з цим боролися? В ідеалі, треба створити тематичні папки,
і розкладати файли по ним. Так само ми вчинимо і з нашими змінними. Об"єкти - це "папки", у які ми будемо складати змінні("файли").
```
var person_1 = {
    name: 'Petro',
    status: 'unmarried',
    gender: 'male'
}

var person_2 = {
    name: 'Mary',
    status: 'divorced',
    gender: 'female'
}
var merry = function(person1, person2){
    if(person1.status == 'married' OR person2.status == 'married'){
        return 'Marriage failed, error code 400';
    }
    if(person1.gender == person2.gender){
        return 'Homosexual marriages prohibited!';
    }
    // !!! дуже важливий момент! Якщо все ок, і пару ми можемо поженити, ми повинні змінити їх статус!
    person1.status = 'married';
    person2.status = 'married';
	return 'Congratulations, ' + name1 + ' and ' + name2 + ', you are married!';
}
```
Оце вже інша справа! Давайте розбиратись.
```
var person_1 = {
    name: 'Petro',
    status: 'unmarried',
    gender: 'male'
}
```
Ось це - справжнісінький об"єкт! Це як наче папка, в якій лежать файли "1.txt", "КУРСОВА!!!!!.doc", "wfnrw7yg9834tn34kt.jpg" і інші.
В якості "файлів" у нас - змінні. Ліва частина об"єкту оголошується так само, як і змінна - var %somename%.
Права частина загорнута у фігурні дужки, і містить перелік змінних, які вкладені в об"єкт.
Зліва пишуться імена змінних(ключі), а справа - значення. Змінні об"єкта називаються властивостями або полями об"єкта.

В об"єкт можна покласти будь-яку змінну, наприклад, логічну або число. Або навіть інший об"єкт!(адже ми можемо покласти папку в папку)
```
var men = {
    name: 'Ivan',
    age: 25,
    gender: 'M',
    wife: {
        name: 'Ann',
        age: 23,
        gender: female,
    }
}
```
Пари "ключ/значення" розділені комами(останню кому бажано не ставити).

А тепер подивимось, як поводитись із об"єктами.
Як добратись до його властивостей? - дуже просто, через крапку!
```
men.name; // "Ivan"
men.age; // 25
men.wife.gender; // "female"
```
Як бачите, рівень вкладеності може бути яким завгодно глибоким!
Можливо, нотація через крапку вам буде незвичною спочатку, т.як асоціюється із закінченням речення або скороченням.
Згадайте компанію Яндекс, яка усі свої сервіси називає через крапку: "Яндекс.Директ", "Яндекс.Розклади" і т.д. Вочевидь, таке йменування виникло по мотивам об"єктної нотації.

# Пусте значення(undefined)

Що буде, якщо ми звернемось до змінної, якої нема?(яку ми не оголошували)
Виникне помилка!
```
alert(some_stupid_name); // помилка!
```
А от якщо спробувати пошукати властивість об"єкта, якої нема, нам це пробачать.
Просто ми отримаємо пусте значення, яке називається undefined.
```
var a = {
	ene: 'bene',
	kvinter: 'finter',
}
console.log(a.zhaba); // undefined
```
Undefined - це таке спеціальне значення, єдине у своєму роді.
Воно трохи схоже на false, тим, що якщо ви будете перевіряти його, воно буде давати негативний результат
```
if(a.zhaba){
	// цей код ніколи не виконається
} else {
	// а оцей - так
}	
```
Однак його не слід плутати із false. Заперечення і відсутність будь-чого - це зовсім різні речі.
Наприклад, вам задають питання, "Чи плямкаєте ви, коли гризете батарею?". Питання поставлене так, що очікується 
відповідь у формі "так" або "ні", true або false. Але, скоріше за все, ви не скажете ні "так", ні "ні", а спробуєте довести своєму співрозмовнику, що ви не гризете батареї.
Ось це і буде undefined.
```
var person = {
	name: 'Zigmund',
	smokes: false
}
if(person.smokes == undefined){
	...
	// дії, якщо це поле відсутнє
}
if(!person.smokes){
	// дії, якщо людина не курить
}
``` 

# Що можна робити з об"єктами

Об"єкти, як ви, можливо, здогадались, є ще одним типом даних(нарівні із числами, строчками і логічними значеннями).
Одна з ними не можна робити майже нічого з того, що ми звикли робити з іншими типами даних.
Їх не можна додавати(віднімати, ділити і т.п.), складати у строчку.

Знову ж таки, звернемось до аналогії з папками. Ви не можете редагувати папку(що ви будете в ній редагувати?!).
Ви можете редагувати файл у папці, можете прибрати файл із папки, додати файл у неї, але сама папка ніяких власнивостей не має, окрім імені.
Давайте подивимось, як виглядають ці операції з об"єктами:
```
var car = {};// створюємо пустий об"єкт

car.power = 1000; // додаємо нову властивість(змінну) в об"єкт, ключ "power", значення 1000.
car.color = 'red';
сar.brand = 'Ferrari';
// тепер подивимось, що вийшло
console.log(car); // Object {power: 1000, color: "red", brand: "Ferrari"} 
// як бачите, коли ми виводимо об"єкт в консоль, він показується нам з усіма властивостями

// Перевіримо, чи є у об"єкта властивість
if(car.color){ ... }

//Однак, ця перевірка не спрацює, якщо в полі color буде значення 0 або false.
//Для того, щоб відрізнити відсутність поля від поля зі значенням false, пишемо так
if(car.color != undefined){ ... }

// спробуємо видалити властивість
delete car.color; // насправді, вам майже не знадобиться ця операція

// редагування змінних об"єкта не відрізняється від початкового присвоєння
car.color = 'yellow'; // тепер колір змінився

// подивимось окрему властивість
console.log(car.color); // 'yellow'

```
Також ми можемо отримати ключ, ім"я якого лежить у змінній!
Для цього існує спеціальна нотація.
```
var man = {
	name: 'Jimmi',
	surname: 'Hendrix',
	job: 'genius',
	age: 28
}

var key = 'name';

console.log(man.name); // Jimmi
//!!! Увага !!!
console.log(man[key]); // Jimmi!

key = 'age';
man[key]++;
console.log(man.age); // 29
console.log(man['age']); // 29
```
Як бачите, є два способи звернутись до ключа об"єкта: через крапку, написавши її безпосереднє значення,
або через квадратні дужки, передавши строчку, яка означає ім"я ключа! Можна передавати безпосередньо строчку або змінну, яка містить строчку.
^
var obj = {a: 2, b: 42, c: 0}
obj[a]; // помилка! Змінної "а" не існує!
^
var obj = {a: 2, b: 42, c: 0}
obj['a']; // good!

//
var k = 'c';
obj[k]; // '0'
^
Такий запис нам знадобиться, коли ми наперед не знаємо, до якого ключа звернутись.

Для початку вистачить. Трохи поліпимо пасочки.
```
// Напишіть функцію create_user, яка приймає ім"я юзера і його прізвище, 
// і повертає об"єкт із полями name і surname
???4%create_user('Ivan', 'A').name === 'Ivan' && create_user('Ivan', 'A').surname == 'A'%
    var create_user = function(n, s){
        var user = {
            name: n,
            surname: s
        }
        return user;
    }
%
```
```
// Напишіть функцію setAge, яка буде приймати об"єкт, що позначає юзера, і число, 
// записуватиме цьому юзеру в поле age це число, і повертатиме об"єкт.
???4%setAge({}, 12).age === 12%
    var setAge = function(user, age){
        user.age = age;
        return user;
    }
%
```
```
/* 
Напишіть функцію celebrateBirthday, яка приймає об"єкт, і дивиться, 
чи є у нього поле age. Якщо таке поле є, вона збільшує його значення на одиницю.
Якщо такого поля нема, то нічого не робить. 
В будь-якому разі, функція повертає об"єкт, який прийняла. 
*/
???4%celebrateBirthday({age: 30}).age === 31 && celebrateBirthday({}).age == undefined%
    var celebrateBirthday = function(user){
        if(user.age !== undefined){
            user.age++;
        }
        return user;
    }
%
```
```
/* 
Напишіть функцію getKey, яка приймає об"єкт і ім"я ключа, і повертає його значення
*/
???4%getKey({age: 30}, 'age') === 30%
    var getKey = function(obj, key){
        return obj[key];
    }
%
```

# Методи

А що буде, якщо запхнути в об"єкт функцію? Це розпосюджений прийом. Функції, як і змінні, корисно групувати.
Тепер, коли ви вже знаєте, що таке об"єкти, ви можете свіжим оком подивитись на нашу стару знайому консоль(console.log), і зрозуміти,
що console - це об"єкт, а log - це його метод(функція, яка записана в поле об"єкта). Крім цього, існують і інші методи, наприклад, console.dir().

В принципі, на перший погляд, робота метода нічим не відрізняється від звичайної функції.
```
var user = {
    name: 'Konrad',
    surname: 'Mikhelson',
    get_fullname: function(name, surname){
        return 'I am ' + name + ' Karlovych ' + surname;
    }
}
```
Начебто, непогано.
```
var full_name = user.get_fullname(user.name, user.surname); // I am Konrad Karlovych Mikhelson

var full_name2 = user.get_fullname('Klara', 'Novikova'); // I am Klara Karlovych Novikova
// ???
```
В принципі, можна було б і так писати код, і ніхто б не скаржився. Але є один механізм, який може спростити нам життя.
Цей механізм, як і багато інших, запозичений із живої мови, він дуже потужний, але, як це буває, ми настільки звикли до нього, що не помічаємо.
Трошки віршів:
```
Не слухала Катерина
Ні батька, ні неньки,
Полюбила москалика,
Як знало серденько.

Полюбила молодого,
В садочок ходила,
Поки Катерину, Катеринину долю
Там занапастила.
```
Стоп-стоп! Щось не те!)))
Тарас Шевченко був майстром української словесності, він вправно використовував усі можливості української мови, у тім числі... займенники!
Тому-то і вірші у нього виходили добре.
```
Не слухала Катерина
Ні батька, ні неньки,
Полюбила москалика,
Як знало серденько.

Полюбила молодого,
В садочок ходила,
Поки себе, свою долю
Там занапастила.
```
Себе! Свою! От так набагато краще! Як бачите, займенники дуже економлять наш час
 і додають виразності і чіткості нашим висловлюванням(якщо правильно ними користуватись).
Тож, навіщо постійно писати ім"я об"єкта, про який і так зрозуміло, що йде мова?
Тепер подумаємо, якби виглядала життєва історія Катерини на джаваскрипті.
```
var Kateryna = {
    gender: 'female',
    status: 'happy',
    future_children: 'good',
    diddle: function(person){ // функція, яка відповідає за занапащення
        person.status = 'unhappy';
    },
    love: function(who, whom){ // передаємо два аргументи, перший - 
    //це хто любить(у нас це буде Катерина), другий - кого люблять
        if(whom.type == 'moscal'){
            // poor Kateryna!
            who.diddle(who); // сама себе занапастила(
            who.future_children = 'bastards';
        } else {
            who.future_children = 'good boys and girls';
        }
    }
}

Kateryna.love('moscal'); // :--(
console.log(Kateryna.status); // unhappy
console.log(Kateryna.future_children); // bastards
```
На жаль, полегшити тяжку долю Катерини ми не в змозі, але, принаймні, ми можемо 
зробити наш код, який описує її страждання, більш красивим.
Що з нашим кодом не так? У ньмоу постійно передається туди-сюди об"єкт Kateryna, 
над яким відбуються модифікації. Хоча ж і так ясно, що якщо у Катерини є метод "занапастити себе",
то його виконання повинне занапастити саме Катерину, і ні кого іншого!

У джаваскрипті є чудовий механізм для методів, який дозволяє використовувати займенники.
Замість того, щоб постійно передавати об"єкт Катерини в аргументах, ми просто будемо вживати займенник "себе"
(до речі, в англійській мові його нема, у джаваскрипті вживається ключове слово this).
```
var Kateryna = {
    gender: 'female',
    status: 'happy',
    future_children: 'good',
    diddle: function(){ // занапащаємо самих себе!
        this.status = 'unhappy';
    },
    love: function(whom){ // аргумент who уже не потрібен, замість нього ми напишемо this!
        if(whom.type == 'moscal'){
            // poor Kateryna!
            this.diddle(); // занапащаємо самих себе
            this.future_children = 'bastards';
        } else {
            this.future_children = 'good boys and girls';
        }
    }
}
```
Як бачите, коли ми викликаємо функцію як метод об"єкту, всередині функції сам цей об"єкт стає доступним через ключове слово this.
Це дуже, дуже важливий момент, читайте попереднє речення і медитуйте над ним, 
поки до вас не прийде розуміння. Ось простіші приклади для засвоєння:
```

var car = {
    color: green,
    brand: 'Mazda',
    getColor: function(){
        return this.color;
    }
}

car.getColor(); // 'green'

car.setColor = function(color){
    this.color = color; 
    //функція нічого не повертає, але вона записує в наш об"єкт новий колір!
}
car.setColor('red');
car.getColor(); // 'red'
```

Звичайно, ми могли б тут вчинити і простіше - записати строчку прямо в поле color
```
car.color = 'red';
car.getColor(); // 'red'
```
Але часто спеціальні функції, які записують дані в об"єкт, бувають корисні,
т.як ми можемо кастомізувати їх поведінку.
```
var car = {
    brand: 'Ford',
    setColor: function(color){
        if(this.brand == 'Ford' AND color !== 'black'){
            // Error! Ford should be black!
            return ;// нічого не робимо, припиняємо виконання функції
        }
        this.color = color; 
    }
}

car.setColor('green'); // не вийде!
car.setColor('black'); // Ok, Ford is black!
car.color; // 'black'
```
За допомогою об"єктів і їх методів ми можемо моделювати(імітувати) поведінку реальних об"єктів.
У програмістів з великим стажем інколи розвиваються сильні професійні деформації, 
внаслідок яких, усі події свого життя вони спримають як сукупність об"єктів, у яких викликаються певні методи.
Наприклад,
```
var man = {
	name: 'Sergiy',
	job: 'programmer',
	status: 'sleeping', // дефолтне значення що він зараз робить
	getStatus: function(){
		return this.status;
	}
	// тут іде перелік методів - все, що він може робити
	sleep: function(){}, // чудова фукнція
	eat: function(){
		/* ... */
	},
	shit: function(){
		/* ... */
	},
	drink: function(){
		/* ... */
	},
	code: function(){
		/* ... */
	},
	// і т.д.
};

man.getUp();
man.eat('banana');
man.drink('tea');
man.goTo('work');
man.getStatus();// coding
man.goTo('home');

// через кілька років
var wife = get_wife();// реалізація цієї функції для багатьох програмістів дещо незрозуміла
wife.wakeUp(man);
var food = wife.cook('breakfast');
food;// 'some awesome breakfast with muffins'
man.eat(food);
man.feelGood();
```

У реальних буденних задачах веб-програмування вам навряд чи доведеться імітувати реальні процеси по типу поїдання бананів.
В більшості випадків, за допомогю об"єктів будуть описані елементи веб-сторінки, а операції, які ви можете зробити з ними, будуть методами.
```
var user = {};
/*
Створіть метод setUsername(name), який встановлює об'єкту user значення поля name
*/

???4%(user.setUsername('Sasha') !== false) && user.name === 'Sasha'%
    user.setUsername = function(name){
	this.name = name;
    }
%

/*
Додайте йому також метод setPassword(pw, repeat_pw), 
який приймає два аргументи(введені юзером пароль і підтвердження пароля).
Якщо вони співпадають, встановлюємо поле password, якщо ні - повертаємо false.
*/
???4%(user.setPassword('111', '111') !== false) && user.password === '111' && !user.setPassword(111, 222)%
    user.setPassword = function(pw1, pw2){
	if(pw1 !== pw2) return false;
	this.password = pw1;
    }
%
/*
Додайте метод login(name, pw), який буде перевіряти, чи збігаються передані ім"я
 і пароль із уже встановленим паролем і іменем юзера.
Якщо збігаються, то встановити поле status юзера в "logged_in", якщо ні - то в "logged_out"
*/
???6%user.name = 'M'; user.password = 'P';user.login('M', 'P');///user.status === 'logged_in' && (user.login('B', 'P') !== false) && user.status === 'logged_out'%
    user.login = function(name, pw){
	if(name === this.name && pw === this.password){
		this.status = 'logged_in';
	} else {
		this.status = 'logged_out';
	}
    }
%
```

# Ще раз про стандартні методи

Тепер ви можете свіжим оком подивитись на стандартні методи, які є, наприклад, у строчок.
```
var str = 'ABCDEFG';
var a = str.charAt(2); // 'C' !!!
```
Наприклад, метод .charAt(), який повертає символ по номеру.
Тільки чому він повернув C, а не В, адже другий по порядку символ - це B?
Справа в тому, що нумерація в джаваскрипті починається з нуля.
```
a = str.charAt(0); // 'A'
```
Так склалось історично, просто прийміть це як є. Цей же принцип відноситиметься і до інших переліків у джаваскрипті.

Але головне питання не в цьому. str - це ж наче просто строчка, і аж ніяк не об"єкт, звідки у неї береться метод charAt?
Відповідь: це такий хитрий трюк від розробників джаваскрипта, щоб полегшити ваше життя.
Звичайно, str з усіх сил старається переконати вас: "Я строчка-строчка-строчка, я зовсім не об"єкт". І str таки дійсно не об"єкт, але деякі властивості об"єкта має.
Це оці стандартні методи. Однак спроба присвоїти строчці якесь поле самотужки не увінчається успіхом.
^
var fruit = 'pear';
fruit.color = 'pink'; // поки все ок, помилки не виникне
console.log(fruit.color); // undefined!
^
var fruit = {name: 'pear'};
fruit.color = 'pink';
console.log(fruit.color); // 'pink'
^
Отже, строчки і числа у джаваскрипті є звичайними строчками і числами, які інколи дозволяють себе вести з ними, як з об"єктами.
Такий їхній лібералізм і доступність значно полегшує життя.
Уявімо, якби усі стандартні методи були функціями.
```
// припустимо, ми маємо функцію charAt(), яка робить те саме, що і метод
var abyrvalg = 'abyrvalg';
var b = charAt(abyrvalg, 1); // 'b'
//і тут раптово!
var charAt = function(str, num){
	return 'ololo';
}

var y = charAt(abyrvalg, 2); // 'ololo' !!!
```
Як бачите, з функціями треба бути обреженим, т.як їхні імена не повинні збігатися з іменами інших функцій і змінних.
Тому, дуже зручно, що більшість стандартних функцій працюють як методи.
Не страшно їх перевизначити, і менше аргументів передавати!

# Об"єкт як словник

Ще одне застосування джаваскриптових об"єктів, окрім моделювання реальних предметів - це функція "словника".
Як працює словник? Ми шукаємо у ньому слово, а він повертає нам його значення.
Так само можна використовувати і об"єкти!
За домопогою них можна співставляти строчки.
Припустимо, ми хочемо написати функцію, яка буде аналізувати українські автомобільні номери.
На вхід ми будемо подавати номер, цільною строчкою, а на виході хочемо отримати об"єкт із його властивостями: область, номер і серія.
```
var plate = 'АН2755КК';
plate = parse_plate(plate); 
console.log(plate); // {region: 'Donetsk', number: '2755', suffix: 'KK'};
```
Для того, щоб написати таку функцію, нам знадобляться деякі строкові методи.
Ми маємо строчку 'АН2755КК', з якої нам треба "вирізати" перші дві букви, потім цифри, а потім останні дві букви.
Для цього є метод .slice(start, end), який повертає частину строчки між позиціями start і end.
```
var plate = 'АН2755КК';
var region = plate.slice(0, 2); // 'AH', символ під позицією end не включається
var number = plate.slice(2, 6); // 2755
```
Ну, частинки номеру ми сік-так виріжемо, а як бути із регіонами?
Нам треба записати, що АН - це Донецька область, АА - Київ і так далі.
Можна, звичайно, зробити це гігантським if/else'ом
```
if(region_code == 'АН'){
	region = 'Donetsk';
} else if(region_code == 'AA'){
	region = 'Kyiv';
} else if(...){ 
	... // і так далі
}
```
Цей спосіб добре підійшов би, якби вам платили не за виконану роботу, а за обсяг написаного коду. Тоді так, це було б чудовим рішенням.
Однак, якщо ви цінуєте лаконічність(а вам доведеться її цінувати, якщо не хочете загрузнути по коліна в коді), то є кращий варіант.
```
var region_names = {
	AA: 'Kyiv',
	AH: 'Donetsk',
	AP: 'Zaporizhzhya',
	...
}
var region_code = 'AP';
var region = region_names[region_code]; // 'Zaporizhzhya'
// !!!
```
Отак набагато краще!
region_names - це об"єкт, який виконує роль словника, він дозволяє, знаючи код області, отримати її назву.
Так як ім"я ключа(код області) нам невідоме наперед, ми шукаємо потрібний елемент у об"єкті за допомогою нотації квадратних дужок.
Давайте тепер спробуємо це склеїти у функцію
```
var parse_plate = function(plate){
	var region_names = {
		AA: 'Kyiv',
		AH: 'Donetsk',
		AP: 'Zaporizhzhya',
		/* і т.д. */
	}
	var region_code = plate.slice(0, 2);
	var number = plate.slice(2, 6);
	var suffix = plate.slice(6);
    // якщо ми не ставимо другий аргумент, це означає - до кінця
	return {
		region: region_names[region_code],
		number: number,
		suffix: suffix
	}
}
```
Однак, необхідно продумати "захист від дурня"(це стандартна задача веб-програмування).
Може таке бути, що людина введе номер, розділивши серію і номер пробілами! Тобто, не 'АН2755КК', а 'АН 2755 КК', і тоді наша логіка,
зав"язана на позиціях літер, полетить к бісовій матері. Цю проблему можна вирішити, якщо превентивно видалити усі пробіли зі строчки!
Ми поки що не вміємо видаляти усі пробіли зараз, тому зробимо це двічі.
```
var parse_plate = function(plate){
	plate = plate.replace(" ", "");
	plate = plate.replace(" ", "");// прибираємо пробіли!
	var region_names = {
		AA: 'Kyiv',
		AH: 'Donetsk',
		AP: 'Zaporizhzhya',
		/* і т.д. */
	}
	var region_code = plate.slice(0, 2);
	var number = plate.slice(2, 6);
	var suffix = plate.slice(6);
	return {
		region: region_names[region_code],
		number: number,
		suffix: suffix
	}
}
```
Тепер ми можемо переписати приклад із реєстрацією і логіном юзера у більш цікавій формі.
```
/*
Нехай у об"єкті userpw лежать пари "логін": "пароль"
*/
var userpw = {
	"Mikolalex": "qwerty123",
	"Eone": "publicPerson",
	"Sasha": "iAmBig",
}
/*
Напишіть функцію create_user(), яка буде приймати ім"я юзера і пароль, перевіряти,
 чи не зайняте це ім"я вже кимось,
і повертати об"єкт з іменем юзера і паролем, якщо все ок, або false, якщо ім"я зайняте.
А також треба вносити у нашу "базу даних" новозареєстрований юзерів!

create_user('John', 'qwerty123'); // {login: 'John', password: 'qwerty123'}
create_user('John', 'qwerty321'); // false (такий юзер вже є)
create_user('Sasha', 'qwerty123'); // false

*/
???6% var u1 = create_user('John', 'qwerty123'), u2 = create_user('Sasha', 'qwerty123'), u3 = create_user('John', 'qwerty123')///u1.login === 'John' && u1.password === 'qwerty123' && !u2 && !u3%
    var create_user = function(login, pw){
        if(userpw[login]) return false;
        userpw[login] = pw;
        return {
            login: login,
            password: pw
        }
    }
%
```
@@@
@@@
## Масиви і цикли
# Масиви

Ми, начебто, оволоділи дуже потужними інструментами, які дозволяють вирішути складні задача програмування.
Але, нам не вистачає деякої дуже важливої складової, без якої ми не зможемо розв"язати елементарнох проблеми.
Зараз я наведу простий приклад, аби ви усвідомили вбогість відомого вам дотепер інструментарію.

Припустимо, у вас є інтернет-магазин, на якому ви торгуєте імпортними товарами. Вам доведеться постійно тримати руку на пульсі подій,
щоб ціни на ваші товари встигали за темпами інфляції. В загальних рисах, це має відбуватись так: щодня ваш скрипт заходить на сайт НБУ(або інше джерело),
дізнається поточний курс, і збільшує ціну товарів пропорційно. Нас поки цікавить друга частина: як описати список товарів і операції над ними.
Треба врахувати, що список товарів буде постійно змінюватися, ви будете додавати нові, і видаляти деякі старі товари.

Варіант "кожен товар - змінна" ми майже одразу відкидаємо:
```
var phone_1 = 'Nokia 1100';
var phone_2 = 'Nokia 1110';
var phone_3 = 'Siemens S55';
...
```
А якщо у нас буде 1000 товарів, ми будемо заводити 1000 змінних? Звісно, ні(так справи не робляться).
Ми вже розуміємось на об"єктах, тож можемо запхнути це все у об"єкт, і зробити, щоб значенням був теж об"єкт із характеристиками товару, а не просто строчка.
```
var goods = {
	phone_1: {
		model: 'Nokia 1100',
		price: '1200',
	},
	phone_2: {
		model: 'Nokia 1110',
		price: '1400',
	},
	phone_3: {
		model: 'Siemens S55',
		price: '2400',
	},
	...
}
```
Це вже краще. Тепер подумаємо, що нам робити, якщо треба додати новий товар.
Специфіка об"єктів полягає у тому, що ключі у них не можуть дублюватися, тобто, не може бути кілька полів із однаковою назвою.
Якщо ми додаємо новий об"єкт, ми повинні знати, який ключ йому присвоїти.
Ми бачимо, що наші ключі мають постійну складову "phone_" і число, яке постійно зростає(1, 2, 3).
Можна десь записувати оце останнє число, і кожному новому товару присвоювати на один більше.
```
var goods_counter = 4;
var add_goods = function(obj){
	var key = 'phone_' + goods_counter; // спочатку буде 'phone_4', і т.д.
	goods[key] = obj;
	++goods_counter;
}
```
Як це працюватиме? При першому звертанні, функцію згенерує ключ 'phone_4', і запиш під ним переданий об"єкт у об"єкт goods.
Однак наступний нам треба вже буде записати під номером 5, тому ми оновлюємо змінну phone_counter, збільшуючи її на одиницю.
Таким чином, кожен раз буде генеруватись новий унікальний ключ.

В принципі, якщо подумати, то префікс "phone_" нам і не потрібен, ми можемо описувати у самому товарі, чим він є(телефоном там чи планшетом).
```
var goods = {
	1: {
		model: 'Nokia 1100',
		price: '1200',
		type: 'phone'
	},
	2: {
		model: 'Nokia 1110',
		price: '1400',
		type: 'phone'
	},
	3: {
		model: 'Siemens S55',
		price: '2400',
		type: 'phone'
	},
	...
}

var goods_counter = 4;
var add_goods = function(obj){
	goods[++goods_counter] = obj;
}
```
І функція add_goods стала простішою.
Вітаю, ви майже винайшли масив!

Що таке масив - це об"єкт, який використовується як список.
При цьому, ключі у нього - це натуральні числа.
У масива є спеціальний синтаксис для опису. Якщо у об"єкті ми використовуємо фігурні дужки, то масив оголошується за допомогою квадратних.
```
var goods = [
	{
		model: 'Nokia 1100',
		price: '1200',
		type: 'phone'
	},
	{
		model: 'Nokia 1110',
		price: '1400',
		type: 'phone'
	},
	{
		model: 'Siemens S55',
		price: '2400',
		type: 'phone'
	},
	...
]
```
Стоп, а де ж поділись ключі? А вони не потрібні! Точніше, вони є, але їх не треба писати! Якщо ключі у масива - це числа, які використовуються для лічби, то нема потреби їх писати.
Баба з возу - кобилі легше. Ключі будуть присвоєні автоматично.
Можна використовувати тільки нотацію квадратних дужок, бо якщо будете писати через крапку число, то інтерпретатор джаваскрипта розгубиться, і не знатиме, що з цим робити.
^
var first_phone = goods.1; // помилка!
^
var first_phone = goods[1]; // ок!
^
Запам"ятати ці всі особливості просто: масив оголошується за допомогою квадратних дужок, і за допомогою них же ми достукуємось до його елементів!
Ключі масива також називаються |індексами|.
Однак, те, що не треба писати самому ключі - це лише одна із вигод масиву.
Додавати нові елементи в нього теж набагато простіше, саме через автоматичне присвоєння ключів.
```
goods.push({
	model: 'Nokia 330',
	price: 3500,
	type: 'phone'
})
```
У кожного масива є метод push(), який додає переданий йому елемент у масив(що б це не було).
Також у кожного масива є властивість length, яка, переважно, означає кількість елементів у ньому, так що, якщо нам треба буде дізнатись сумарну кількість товарів,
нам не треба буде нічого рахувати, ми візьмемо готовий результат.
Ще приклад для засвоєння:
```
var fruits = []; // оголосили пустий масив

console.log(fruits.length); // 0 кількість елементів у масиві також називають "довжиною" масиву

fruits.push('banana');
console.log(fruits[0]); // 'banana' - нумерація починається з нуля!
console.log(fruits[1]); // undefined
console.log(fruits.length); // 1

// покладемо щось у масив
fruits.push('pear'); 
console.log(fruits[1]); // 'pear'
console.log(fruits.length); // 2

// поглянемо...
console.log(fruits);// ['banana', 'pear']

// подивимось якийсь конкретний елемент, наприклад, другий
console.log(fruits[2]); 
// або
var el_num = 2;
console.log(fruits[el_num]);
// Як бачите, доступ до елемента масиву здійснюється через квадратні дужки


// і заберемо щось із нього)
var pear = fruits.pop(); // метод pop() видаляє останній елемент масиву і повертає його
console.log(fruits);// ['banana']
console.log(pear);// 'pear'
```
Ще про те, як звернутись до елемента масиву:
^
var a = ['steamer', 'diesel', 'electro'];
var steam = a.0; // та не можна
^
var a = ['steamer', 'diesel', 'electro'];
var steam = a[0];
// або ж
var l = 0;
var steamer = a[l];// в якості ключа передається змінна!
^

Трохи завдань.

Є дівчинка Даша, яка має різноманітні захоплення(іншими словами, об"єкт із полем name = Dasha, який має також поле hobbies - масив), які інколи змінюються(додаються)
Однак люди не можуть займатись одночасно десятком справ, тому ми повинні передбачити обмеження: не більше 3 хоббі одночасно.
Створіть метод addHobbie для додавання нового захоплення Даші.
Якщо пробуємо додавати 4-е хоббі, то повернути false, інакше - повертаємо true.
```
var girl = {
	name: 'Dasha',
	hobbies: ['lindy-hop', 'balboa'],
}

???6%girl.addHobbie && girl.addHobbie("HTML") && girl.hobbies.length === 3 && !girl.addHobbie("CSS") && girl.hobbies.length === 3%
	girl.addHobbie = function(n){
		if(this.hobbies.length >= 3){
			return false; // Too much!
		} else {
			this.hobbies.push(n);
			return true;
		}
	}
%
/*
girl.addHobbie('Javascript'); // true
girl.addHobbie('Photography'); // false
*/
```
# Цикли

Однак, як буде виглядати код, який збільшить ціни усім товарам у масиві на 10%?
```
var goods = [
	{
		model: 'Nokia 1100',
		price: '1200',
		type: 'phone'
	},
	{
		model: 'Nokia 1110',
		price: '1400',
		type: 'phone'
	},
	{
		model: 'Siemens S55',
		price: '2400',
		type: 'phone'
	},
	...
];
var increase_price = function(percents){
	goods[0].price = goods[0].price * (1 + (percents/100));
	goods[1].price = goods[1].price * (1 + (percents/100));
	goods[2].price = goods[2].price * (1 + (percents/100));
	goods[3].price = goods[3].price * (1 + (percents/100));
	goods[4].price = goods[4].price * (1 + (percents/100));
	...
}
```
Святі угодники! Так ми ніяких строчок не напасемось! Писати по строчці коду на кожен товар - це дуже неефективно.
Давайте помізкуємо, що у нас тут відбувається. Для кожного товару ми виконуємо одну й ту ж саму послідовність дій, можливо, це треба винести у функцію.
```
var increase_item_price = function(item, percent){
	item.price = item.price * (1 + (percents/100));
}

var increase_price = function(percents){
	increase_item_price(goods[0], percent);
	increase_item_price(goods[1], percent);
	increase_item_price(goods[2], percent);
	increase_item_price(goods[3], percent);
	increase_item_price(goods[4], percent);
	...
}
```
Уже приємніше, хоча ми і не зменшили загальну кількість строчок.
Якщо придивитись, ми бачимо, що кожного разу викликаємо одну й ту ж функцію, змінюється лише значення ключа(0, потім 1, 2, 3 і так далі).
Можна переписати це так:
```
var increase_price = function(percents){
	var i = 0; // "i" якби означає "індекс", ви ж пам"ятаєте, що ключі масива називають індексами?
	increase_item_price(goods[i], percent);
	++i; // тепер i вже дорівнює 1
	increase_item_price(goods[i], percent);
	++i;
	increase_item_price(goods[i], percent);
	++i;
	increase_item_price(goods[i], percent);
	++i;
	increase_item_price(goods[i], percent);
	++i;
	increase_item_price(goods[i], percent);
	++i;
	...
}
```
Тепер ми добилися того, що наші строчки виглядають взагалі ідентично, хоч бери і копіпасти сотнями! Звісно, копіпастити ми не будемо.
Подумаємо ще раз.
Наша задача: якось так зробити, що оцей код(increase_item_price(goods[i], percent);) викликався стільки разів, скільки є елементів у масиві.
Тільки кожного разу повинно збільшуватись на одиницю значення "і".
Ось тут нам і допоможуть цикли.
```
var increase_price = function(percents){
	var i = 0; // початкове значення "і" 
	while(i < goods.length){ // перевірка, 
                             // яка буде проводитись після кожного виконання циклу
		increase_item_price(goods[i], percent);
		++i; // збільшимо і на одиницю, щоб перейти до наступного індекса
	}
}
```
Ось це і |все|! Знайомтесь, це цикл! Цикл - це така конструкція, яка дозволяє виконувати задані рядки коду стільки разів, скільки треба!
Спочатку про синтаксис(тут схоже на функцію): є ключове слово(while), далі в дужках пишеться |умова циклу|, і далі, у фігурних дужках - |тіло цикла|.
Однак, цикл не схожий на функцію. Функція, в момент оголошення, нічого не робить, вона починає виконуватись, тільки коли ми її викликаємо.
Цикл виконується одразу, там де ми його написали.
Як і у функції, тіло цикла - це будь-який код.

Найцікавіше - це умова циклу, те, що написано в його дужках.
Я не дарма назвав це умовою, т.як це вираз, який обчислюється як логічне значення(true або false) при кожному виконанні циклу.
Цикл буде виконуватись, поки умова буде вірною, тобто true.
Якщо написати так, що умова буде вірною завжди, то цикл буде виконуватись вічно! 
Так, вічно, поки ваш комп"ютер не зависне або браузер не вб"є ту вкладку, на якій виникло таке неподобство.
Ми повинні обмежити виконання циклу: стільки разів, скільки у нас елементів у масиві.
Для цього ми будемо кожного разу порівнювати змінну "i" з довжиною масиву. 

Умову для циклу можна формувати як завгодно, голове - це щоб ваш цикл коли-небудь припинив функціонування.
Наприклад, попередній приклад буде ідентично працювати і в такому вигляді:
```
var increase_price = function(percents){
	var i = 0; // початкове значення "і" 
	while(goods[i]){
		increase_item_price(goods[i], percent);
		++i;
	}
}
```
Тут умова цикла(goods[i]) - це просто наявність в масиві ключа номер "i".
Ми будемо поступово збільшувати змінну "і", і в якийсь момент вона стане більшою, аніж останній ключ в масиві,
і goods[i] буде undefined, цикл припинить своє виконання.
Однак така перевірка дещо гірша, аніж перший варіант, т.як буде довше виконуватись(порівняння двох чисел буде швидшим, аніж перевірка наявності індекса в масиві).

Цикли не обов"язково використовуються для обходу масивів, але дуже часто. Інколи вони потрібні і для інших задач.
Наприклад, якщо нам треба отримати суму чисел від 0 до якогось заданого числа.
```
var sum = 0;
var num = 0;
var limit = 42;
while(num < limit){
    sum += num; // це запис еквівалентний: sum = sum + num;
    ++num;
}
console.log(sum); // 861
```

# Цикл for

Це посипана цукровою пудрою версія циклу while.
Якщо ви придивитесь до циклів while, то майже завжди можна побачити 3 складові: 

а) початкове призначення змінної(var i = 0 в першому прикладі, var num = 0 в другому).

б) обмеження(те, що власне записано в умові цикла)

в) модифікація змінної(збільшення на одиницю, переважно)

У циклі for це все зібрано докупи:
```
var increase_price = function(percents){
	for(var i = 0; goods[i]; ++i){
		increase_item_price(goods[i], percent);
	}
}

var limit = 42;
for(var num = 0, sum = 0; num < limit; ++num){
    sum += num;
}
console.log(sum); // 861
```
Те саме, але значно коротше! Три складові пишуться через крапку з комою. Оголошення кількох змінних зліва можна робити через кому.
Будь-яку із цих трьох складових можна, в принципі, пропустити:
```
for(;;){} // вічний цикл, але буде працювати!
```
Тепер практика.
Напишіть фукнцію sum(arr), яка складає усі елементи масива:
```
// var a = [10, 23, 40];
// sum(a);// 73
???6%sum([1, 2,3]) === 6%
	var sum = function(arr){
		var s = 0; // початкове значення змінної, яка відповідає за суму
		for(var i = 0; i < arr.length; i++){
			// на кожному кроці додаємо значення елемента масива до суми
			s += arr[i];
		}
		return s;
	}
%
```
Тепер напишіть функцію join(arr, glue), яка буде повертати строчку, склеєну із елементів масива arr, 
після кожного елемента буде додаватись строчка glue.
```
// join(["I", 'love', 'you'], " "); // 'I love you '
// join(["I", 'love', 'you'], ""); // 'Iloveyou'
// join([1, 2, 3, 4], "/"); // '1/2/3/4/'
???10%join([1, 2, 3], "+") === '1+2+3+'%
var join = function(arr, glue){
	var res = '';
	for(var i = 0; i < arr.length; i++){
		res += arr[i] + glue;
	}
	return res;
}
%
```
Насправді, аналогічна функція вже існує в формі методу join(), який є у будь-якого масива, тільки працює дещо краще(не додає "glue" після останнього елемента)
```
var a = [3, 4, 5];
a.join("-"); // '3-4-5'
```

Напишіть фукнцію fill(num, str), яка буде створювати масив із заданої кількості num елементів str.
Наприклад, fill(4, 'ololo') поверне ['ololo', 'ololo', 'ololo', 'ololo']
Підказка: ця функція повинна повертати(return) масив. Вочевидь, щоб повернути масив, якого не було,
ми повинні його спочатку створити. 
```
???10%(fill(10, 'x')[9] === 'x') && (fill(10, 'x')[0] === 'x') && (fill(10, 'x').length === 10)%
var fill = function(n, val){
	var res = [];// створюємо пустий масив
	for(var i = 0; i < n; i++){ // цикл буде виконуватись n разів
		// на кожному "обороті" додаємо елемент val у масив
		res.push(val); 
	}
	// після циклу повертаємо те, що вийшло
	return res;
}
%
```

# Цикл for in

Це такий окремий підвид циклу for, який працює... зовсім інакше.
Обійти масив не складно(якщо його ключі йдуть по порядку): ми беремо початкове значення(здебільшого 0), кінцеве, і проходимо по усім цілим числам в цьому діапазоні, які будуть ключами масиву.
А як обійти об"єкт? Ключі у об"єкта можуть бути які завгодно. Ось для цього нам потрібен цикл for in.
Він не схожий на інші цикли, т.як не містить ніяких умов. Грубо кажучи, ми просто показуємо йому, який об"єкт обійти, і як називати ту змінну, яка буде ключем.
```
    var lamp = {
        color: 'lime',
        capacity: 200,
        price: 150
    }
    for(var key in lamp){
        console.log('Key', key, ', value', lamp[key]);
    }
    /*
    Key color , value lime
    Key capacity , value 200
    Key price , value 150 
    */
```
На кожному обороті цього циклу у змінну key буде записуватись ключ об"єкта: спочатку color, потім capacity i price.
Значення можна отримати, передавши цю змінну в якості ключа у об"єкт: lamp[key].
Таким чином, ми можемо виконувати певний код над кожним елементом об"єкта.

Оскільки масив - це такий особливий об"єкт, але все ж таки об"єкт, то цикл for in можна виконувати і на ньому!
```
    var fruits = ['banana', 'apricot', 'peaches'];
    for(var i in fruits){
        console.log('I like ' + fruits[i]);
    }
    /*
        I like banana
        I like apricot
        I like peaches 
    */
```
Виникає питання, яким циклом краще обходити масив?
Мій варіант - по можливості for in, т.як він простіше пишеться, а також не буде проблем, якщо масив розріджений(якісь із елементів пропущені).
Однак, цей спосіб інколи може бути незручним, якщо у вашого масива є і інші властивості. Так що, питання залишається відкритим до тих пір, поки ви не попрактикуєте обидва варіанти.

Напишіть функцію toHTML(obj), яка повертає із переданого об"єкта строчку, де кожен елемент загорнутий в дів з класом(див. приклад)
```
var lens = {
	brand: 'Tamron',
	price: 100500,
	focal_length: '70-300'
}
var h = toHTML(lens);
console.log(h);/*
 <div class="brand">Tamron</div>
 <div class="price">100500</div>
 <div class="focal_length">70-300</div>
*/
```
```
???10%toHTML({a: 'b'}).indexOf('class="a"') !== -1 && toHTML({a: 'b'}).indexOf('>b</div>') !== -1%
	var toHTML = function(obj){
		var res = '';
		for(var key in obj){
			res += '<div class="' + key + '">' + obj[key] + '</div>';
		}
		return res;
	}
%
```

# Вихід із циклу

Інколи, нам треба обірвати виконання циклу дещо раніше, аніж це передбачено його умовою.
Наприклад, у вас є жменька квитків на тролейбус, і деякі з них вже використані(закомпосовані).
Ви хочете знайти хоча б один не прокомпостований квиток, щоб скористатись ним.
Якими будуть ваші дії:
а) перевіряємо кожен квиток із жменьки, поки не дійдемо до кінця
б) якщо знайдено незакомпостований квиток, взяти його, і |припинити подальший пошук|.

Фішка в тому, що ви не знаєте, коли ж ви знайдете той "чистий" квиток, і чи знайдете його взагалі.
Тому ви пишете цикл по всій пачці. Однак, якщо ви таки знайдете потрібний квиток, то далі шукати нема сенсу - мету досягнуто.
Як це виглядатиме на джаваскрипті?
```
var tickets = ['used', 'used', 'used', 'unused', 'used', 'unused', 'unused'];
for(var position in tickets){
    console.log('checking key ' + position);
    if(tickets[position] === 'unused'){
        break;
    }
}
/*
    checking key 0
    checking key 1
    checking key 2
    checking key 3 
*/
console.log(position); // 3
```

Отже, ви тепер знаєте чудовий оператор break, який припиняє роботу цикла!
Як бачите, ми дійшли до четвертого ключа(3), і, побачивши що там невикористаний квиток, припинили роботу!

Також, зверніть увагу, що цикл, на перший погляд, не робить нічого корисного: там не відбувається ніяких присвоювань, не викликаються функції.
Однак, він дає нам головне - позицію першого невикористаного квитка. Змінна position після виконання циклу і його переривання буде дорівнювати якраз
позиції шуканого квиточка!

Давайте, заодно, подивимось, як ми можемо зімітувати "діставання квитка" із пачки.
Для цього нам знадобиться метод splice, який вирізає задані елементи із масива і повертає їх у вигляді нового масиву. 
```
var tickets = ['used', 'used', 'used', 'unused', 'used', 'unused', 'unused'];
for(var position in tickets){
    if(tickets[position] === 'unused'){
        break;
    }
}

var active_ticket = tickets.splice(position, 1); // ['unused']
tickets; // ['used', 'used', 'used', 'used', 'unused', 'unused'] 
// те саме, тільки без 4 квиточка
```

@@@
@@@
## Важливі моменти, які треба знати перед початком серйозної роботи

Перш ніж ми почнемо робити мінімально-реалістичні задачі, я роз"ясню деякі нюанси. Дотепер я розказував головні базові речі джаваскрипта, і деякі 
деталі опускав, аби не забивати вам голову купою дрібниць. Якщо ви не зрозуміли, що таке розгалуження і цикли, і не розумієте різницю між об"єктом і масивом,
то нема сенсу говорити про тонкі деталі. Вони вам не допоможуть зрозуміти основне, а навпаки, заплутають ще більше.

Однак, якщо ви розібралися з основними принципами, вам ще треба запам"ятати низку особливостей, без знання яких ви ризикуєте стати бидлокодером.
# Про var
Отже, для чого потрібно оце слово і де його вживати? Слово вар потрібне для того, щоб чітко окреслити область видимості змінної!
Розглянемо на прикладі:
^
var a = 25;
var add_42 = function(num){
	a = 42;
	return num + a;
}

add_42(a); // 84
console.log(a); // 42...
^
var a = 25;
var add_42 = function(num){
	var a = 42;
	return num + a;
}

add_42(a); // 67
console.log(a); // 25
^
По нашому задуму, функція add_42 повертає число, додане до 42.
У нас є "зовнішня"(глобальна) змінна "а", і "внутрішня" змінна "а", яка використовується функцією.
Для того, щоб показати, що це різні змінні, ми використовуємо слово var(другий приклад), інакше інтерпретатор подумає, що це одна й та сама змінна(перший приклад).
Вам часто доведеться оголошувати змінні всередині функцій, функції всередині функцій і т.д., тому використання var необхідне, аби уникнути можливих колізій.

Якщо ви просто присвоїте змінну, яка до цього не була оголошена, без вар, то у вас, в залежності від ситуації, може виникнути помилка або ця змінна стане глобальною.
```
var three_times = function(str){
	i = 0;
	while(i < 3){
		str += str;
	}
	return str;
}
three_times('Fight!'); // Fight!Fight!Fight!
// начебто все ок, але 
console.log(i); // 3 !
```
Як бачите, змінна, яка була одразу використана без оголошення через var, стає глобальною, кажуть, що вона "витікає" у глобальну область видимості, що небажано.
Так що ключове слово var необхідно завжди писати при першому використанні змінної.

# Про ініціалізацію

Перше використання змінної називається ініціалізацією. Це треба робити із використанням ключового слова var. Можна проводити "групову" ініціалізацію, 
написавши кілька змінних через кому, при цьому слово var пишеться
лише один раз, на початку.
```
var name = 'Sasha', 
	nickname = 'Big', 
	age = '30';
```
Також можна оголошувати змінні, не присвоюючи їм ніякого значення!
```
	var a, 
		b,
		c = 42;
```
Змінні a і b будуть створені, їм буде присвоєне значення undefined.
А для чого взагалі це робити, якщо не присвоювати змінній значення? Прочитайте ще раз попередній параграф)


# Про типи змінних
Кожна змінна у джаваскрипті має тип. Всього типів шість. Перші три вам давно відомі: число(number), строчка(string), логічне значення(boolean).
Є ще два трохи дивних типи, які мають лише по одному значенню: тип undefined(який має одне значення - undefined) а також тип null(який має одне значення - null).
А також особливий тип object, всі об"єкти, |функції| і масиви мають цей тип.

Ви звикли, що можете передавати у функції будь-які змінні. Наприклад,
```
var exp = function(a){
    return a * a;
}
exp('ololo'); // NaN
```
По ідеї, функція exp() має приймати число(це ми можемо побачити, якщо заглянемо в її нутрощі).
Однак, ми ніде явно не вказали, що ми хочемо отримати в якості аргумента "а" саме число. 
Справа в тому, що в багатьох мовах(наприклад, С і С++) вам доводиться наперед явно вказувати, якого типу повинен бути переданий аргумент.
Однак джаваскрипт - це дуже ліберальна мова, яка дає вам велику свободу, а разом з нею - і відповідальність.
Простіше кажучи, у джаваскрипта немає ніякого захисту від плутанини з типами.
Відповідальність за те, щоб передавати правильні типи у функції, лежить повністю на вас!

У джаваскрипті ви ніяк не описуєте, якого типу змінні повинна приймати функція.
Більшість операцій і функцій достатньо гнучкі, і не дуже прискіпливо відносяться до аргументів, які їм передано.
Однак, все одно треба завжди чітко розуміти, якого типу та чи інша змінна.
```
var concat = function(a, b){
    return a + b;
}
concat(1, 7); // 8
concat('1', '7'); // 17
concat(1, '7'); // 17
concat(1, 'John'); 1John
concat('John', 1); John1
// трошки хардкору
concat([], {});// '[object Object]' - це просто така строчка! о_О
```
Як бачите, Джаваскрипт, будучи дуже терплячою мовою, чесно намагається виконанти арифметичне додавання пустого об"єкта і масива, не кажучи за інші випадки.
Чому був отриманий саме такий результат(строчка '[object Object]') - це окрема тема.

Можливо, зараз вам такі проблеми здаються трошки надуманими. Типу, ну а навіщо передати масив туди, де потрібна строчка?
Справа в тому, що у великих програмах часто буває важко відслідкувати, де змінна з"являється і як вона змінюється.
Тому часто доводиться дізнаватись тип змінної прямо на місці, і діяти на основі цього.

Робота із типами даних, відверто кажучи, не є сильною стороною Джаваскрипта.
Наприклад, не існує єдиного уніфікованого способу дізнатись тип змінної.
Взагалі, для цього був створений оператор typeof, але він веде себе місцями неадекватно.
```
typeof 'ololo'; // "string"
typeof 42; // "number"
typeof {}; // "object"
typeof undefined; // "undefined"
typeof false; // "boolean"
```
Поки все ок, а ось не дуже приємні моменти:
```
typeof function(){}; // "function" - такого типу просто нема
typeof null; // "object" - невірно, тип змінної null - null
```

Отже, наприклад, перевірка, чи є змінна об"єктом, виглядатиме так:
```
var isObject = function(a){
    return typeof a === 'object' AND a !== null;
}

```

# Про другий спосіб оголошення функцій
Окрім виразу виду 
```
var a = function(){}
```
котрий ми використовували дотепер,
є і інший варіант:
```
function a(){
		...
}
```
Перший варіант називається functional expression, а другий - functional declaration.
Functional expression прекрасний тим, що він нам нагадує, що функція - це така ж змінна, як і інші.
functional declaration є більше традиційною формою оголошення функцій, і теж інколи може бути корисним.
Головна його перевага - таку функцію можна використовувати до її оголошення.
^
say('Hello!');
var say = function(str){
		console.log(str);
}
// невірно, ми використовуємо змінну say до того, як ми її оголосили, буде помилка
^
say('Hello!');
function say(str){
		console.log(str);
}
// все ок!
^
Коли інтерпретатор джаваскрипт починає аналізувати код, який ви написали, він в першу чергу знаходить оці ось functional declarations,
таким чином, функції стають доступними в будь-якому місці.

Однак, якщо одну й ту саму функцію оголосити двома різними способами, "переможе" варіант functional expression.
```
var a = function(){
	console.log('B');
}
function a(){
	console.log('A');
}

a(); // 'B' !
```
Варіант із expression(запис функції у змінну) завжди перекриває варіант із декларацією функції.
Я рекомендую кругом використовувати саме functinal expression, крім тих випадків, де без нього не можна обійтись.

# Про функцію як об"єкт першого класу

Якщо подивитись, як ми оголошуємо функцію, то побачимо, що різниці між оголошенням змінної і функції практично нема.
Тобто, функція - це теж змінна, тільки дещо специфічна(у змінної є ЗНАЧЕННЯ, а функцію можна ВИКЛИКАТИ).
Якщо змінні можна передавати у функції в якості аргументів, то чи можна функціїь передавати у функції? Так!
```
var do_twice = function(f, arg){
    f(arg);
    f(arg);
}
var show_msg = function(msg){
    console.log(msg);
}
do_twice(show_msg, "Access granted!"); // Access granted!Access granted!
```
У нас є дві функції, перша(do_twice) приймає два аргументи, при чому перший із них(f) має бути функцією, т.як він викликається!
Ми передаємо функцію show_msg у функцію do_twice, і функція do_twice двічі викликає функцію show_msg в якості аргумента f!

Коли функція зовсім проста і легкочитабельна, ми можемо не створювати окрему змінну, а просто передати функцію прямо як аргумент:
```
var do_twice = function(f, arg){
    f(arg);
    f(arg);
}
do_twice(function(msg){ console.log(msg); }, "Access granted!"); // Access granted!Access granted!
```
Коли ми передаємо анонімну функцію як аргумент, це називається "анонімна функція", або "лямбда".

[Увага! Матеріал підвищеної складності!]
За допомогою передачу функцій як аргумента можна реалізовувати дуже багато цікавих технік, які складають основу функціонального програмування.
Наприклад, ми хочемо на основі загальної функції створити більш специфічну.
```
// загальна функція
var multiply = function(a, b){
    return a * b;
}
// більш специфічна - результат виконання першої функції із одним наперед встановленим аргументом
var multiply_on_two = function(b){
    return multiply(2, b);
}
multiply_on_two(4); //8
```
Поки що тут нема нічого нового. А як це узагальнити?
Як написати загальний метод, який би дозволяв створювати більш специфічну функцію на основі загальної, фіксуючи, скажімо, перший аргумент із двох?
```
var fix_first = function(func, a){
    return function(b){
        return func(a, b);
    }
}
var multiply_on_two = fix_first(multiply, 2);
```
В подальшому ми детальніше розглянемо усі можливості, які відкриває перед нами можливість вільно оперувати функціями.
# Про window, глобальні змінні i this
Я вже неодноразово вживав слово "глобальна змінна". Так що це таке, якщо бути точним? Глобальна змінна - це змінна, яка оголошена на верхньому рівні(тобто, НЕ всередині якоїсь функції).
Відповідно, її називають глобальною, бо доступ до неї є кругом: і на верхньому рівні, і всередині функцій.
Однак є і ще спосіб отримати глобальну змінну, окрім як звернутись до неї по імені.
Річ у тім, що усі глобальні змінні є полями глобального об"єкта window.
```
var a = 35;
console.log(window['a']); // 35
```
Вони потрапляють туди автоматично, це складова мови джаваскрипт.
Яка з цього може бути практична корисність?
Ну наприклад, ви хочете оголосити змінну, але не впевнені, чи вільне її ім"я(чи не оголошена вона часом раніше).
^
if(!a){
	var a = 35;
}
// Поганий варіант, якщо змінної "а" дійсно нема, при спробі її перевірити виникне помилка!
^
if(!window.a){ // так помилки не буде!
	var a = 35;
}
^
Також інколи хочеться створити глобальну змінну в функції
^
var some_f = function(){
	...
	// ця змінна буде локальною для функції
	var i_am_global = true;
	...
}
console.log(i_am_global); // помилка
^
var some_f = function(){
	...
	// а так ми створимо дійсно глобальну змінну
	window.i_am_global = true;
	...
}
console.log(i_am_global); // true
^
Також, якщо ви виконаєте функцію, яка містить звертання до контексту(слово this) поза об"єктом, змінна this буде вказувати на об"єкт window!
```
var a = 10, b = 20;

var stupid_func = function(){
	this.c = this.a + this.b;
}
stupid_func();// ми просто виконуємо функцію, без прив"язки до об"єкта, 
// this вказує на window з усіма наслідками 
console.log(c); // 30 - змінна c "записалась" в глобальні!
```
Розповсюджена помилка:
```
var caller = function(some_func){
	// ця функція просто приймає передану їй функцію і викликає її
	some_func();
}
var boy = {
	name: 'Mykyta',
	stomach: [],
	likes: {cucumbers: true, bananas: true, carrots: true},
	feed: function(something){
		// якщо це є у списку продуктів, що подобаються Микиті
		if(this.likes[something]){ 
			// то "поповнюємо" цим вміст його шлунка
			this.stomach.push(something); 
		} else {
			console.log('Ffffuuu!');
		}
	}
}
// починаємо годувати
boy.feed('onions'); // FFFUUU!
boy.feed('cucumbers'); // ok!
boy.stomach; // ['cucumbers']
// Поки все ок!

caller(boy.feed); // функція feed буде виконана поза своїм очікуваним контекстом!
// виникнуть численні помилки, т.як this буде дорівнювати window.
```
# Про call
Call - це такий метод, за допомогою якого можна виконати функцію, як начебто вона є методом іншого об"єкта.
Це як наче у кіно: ви сидите, дивитись на екран, і усі події і емоції, які переживає герой, пропускаєте крізь себе, хоча усе відбуваються насправді не з вами, а з героями фільму.
Приклад:
^
var city = {
	name: 'Kiyv',
	weather: 'cloudy'
}

var let_it_snow_in_the_city = function(){
	this.weather = 'snowy';
}
let_it_snow_in_the_city();// чорт зна що, при виконанні функції this буде дорівнювати глобальному об"єкту window
console.log(city.weather); // 'cloudy' нічого не змінилось, та і не повинно було змінитись
console.log(window.weather); // змінна weather успішно "витікла" в глобальну область видимості
^
var city = {
	name: 'Kiyv',
	weather: 'cloudy'
}

var let_it_snow_in_the_city = function(){
	this.weather = 'snowy';
}
let_it_snow_in_the_city.call(city);
console.log(city.weather); // 'snowy'
console.log(window.weather); // undefined
^
Конструкція somefunc.call(someobj) означає "запустити функцію somefunc так, ЯК НІБИТО вона є методом об"єкта obj"
У нашому випадку, це буде так, як наче б ми написали:
```
var city = {
	name: 'Kiyv',
	weather: 'cloudy'
	let_it_snow_in_the_city: function(){
		this.weather = 'snowy';
	}
}
city.let_it_snow_in_the_city();
```
@@@
@@@
## Робота з DOM(з допомогою jQuery)

Тепер ви вже знаєте основні конструкції джаваскрипта, і пора вже спробувати реальну роботу - створення інтерактивних динамічних веб-сторінок із допомогою джаваскрипта.
Це те, для чого джаваскрипт був з самого початку задуманий і створений. 

У джаваскрипта є кілька аспектів, в яких він взаємодіє з веб-сторінкою і юзером.
а) зміна ХТМЛа сторінки. Це найголовніший момент. Джаваскрипт може втручатися у готову зрендерену ХТМЛ сторінку і міняти в ній що завгодно: вставляти нові теги,
змінювати існуючі, видаляти їх, змінювати стилі тегів і т.д.
б) взаємодія з юзером через власні засоби, типу alert(), який виводить повідомлення юзеру, і інші. Це малочисельна група, і її вживання поступово скорочується на користь першої групи
(тобто, замість того, щоб писати дубовий alert(), ви можете змодифікувати хтмл вашої сторінки так, що на ній з"явиться красиве вікно з діалогом).
в) маніпуляція із сторінкою: джаваскрипт може змінювати адресу сторінки(направляючи вас, по суті, на іншу адресу), оновлення сторінки і т.п. Це все робиться з допомогою
функцій, які заховані в деяких стандартних змінних джаваскрипта.
г) зберігання і управління інформацією, наприклад, за допомогою ajax, cookies, localStorage і т.п. Цей аспект зазвичай невідомий більшості простих 
юзерів, ми помічаємо лише результати його роботи, але не бачимо, що під капотом. Так що, поки що не намагайтесь вникнути і запам"ятати, що це, пізніше роздивимось.

Поки що будемо роздивлятись найбільш потрібну частину, а саме пункт "а". По дорозі ми розберемо кілька цікавинок джаваскрипта, які важко було б зрозуміти на вихолощених абстрактних прикладах.
Спочатку розберемось із термінологією.
Що таке DOM? DOM(document object model) - це така структура, яка утворюється на основі ХТМЛа при рендерингу сторінки.
ХТМЛ, є, по суті, лише текстом, в той час як ДОМ - це вже готові джаваскрипт-об"єкти із властивостямиі методами, які відображають струкктуру ХТМЛа.
Приблизно уявити собі це можна так. Якщо у нас є такий ХТМЛ:
```
<body>
	<h1>Mechanix</h1>
	<div class="song">
		<div class="chorus">
			Whoever thought you'd be better
			At turning screw than me
			I do it for my life
			Made my drive shaft crank
			Made my pistons bulge
			Made my ball bearing melt from the heat
			Oh yeah yeah
		</div>
		<div class="author">
			Dave Mustaine
		</div>
	</div>
</body>
```
Це, нагадую знову, лише текст, поки що. А як відобразити цю структуру за допомогою джаваскрипт об"єктів?
Давайте подумаємо. Кожен тег - це об"єкт - може містити в собі інші теги. Або текст. Також кожен тег характеризується
назвою(div, span і т.п.), атрибутами(class, href). Отже, вимальовується така схема: у кожнго тега є обов"язкові властивості(tagName, строчка) і опціональні(children, масив таких же об"єктів, що позначають теги, attributes, об"єкт із значеннями атрибутів, text - строчка)
```
var document = {
	tagName: 'body'
	children: [
		{
			tagName: 'h1',
			text: 'Mechanix',
		},
		{
			tagName: 'div',
			attributes: {
				class: "song",
			}
			children: [
				{
					tagName: 'div',
					class: 'chorus',
					text: 'Whoever thought you'd be better...',
				},
				{
					tagName: 'div',
					class: 'author',
					text: 'Dave Mustaine',
				},
			]
		},
	]
}
```
Ось так |приблизно| виглядає ДОМ. Справжній ДОМ створюється автоматично браузером під час завантаження сторінки, і назви полів там трохи інші.
Кореневий об"єкт, у якому лежать усі інші - це глобальна змінна document. Далі ви можете знайти будь-який елемент, риючись в його прямих нашадках(document.children), нащадках нащадків і т.д.
document.children[0].children[1] - скоріше за все, це буде елемент body.
На відміну від нашого умовного ДОМа, який був наведений вище, реальні дом-об"єкти(їх називають вузли, ноди(від англ. "node" - вузол)) мають набагато більше властивостей.
Але це ще півбіди. Якщо дуже захочете, ви знайдете потрібну інформацію. Наприклад, атрибути лежать там, де і треба - в полі attributes.

Найбільша проблема в тому, як знайти потрібний елемент. Припустимо, нам треба змінити вміст тега div.author із "Dave Mustaine" на "Megadeth".
Як нам знайти у ДОМі потрібний тег? Приблизний алгоритм був би такий:
а) беремо дом-вузол.
б) перевіряємо, чи відповідає він нашим вимогам(чи має клас author і чи є цей тег тегом div).
в) якщо так, то припиняємо пошук
г) якщо ні, то беремо поле children цього тега, і з кожним його елементом(нащадком) виконуємо ті ж самі дії.
Ось такий непростий алгоритм. Його можна реалізувати за допомогою рекурсії, але цю тему ми розглянемо дещо пізніше, а поки що підемо шляхом найменшого опору - візьмемо готове рішення.

# Знайомство з jQuery

На практиці, шукати ДОМ-вузли і виконувати з ними якісь дії доводиться дуже часто. Програмісти не люблять зайвої роботи,
і намагаються автоматизувати і узагальнити усе, що можна, і навіть більш за те. Тому для роботи із ДОМ було створено багато бібліотек. На даний момент, абсолютним лідером серед них є бібліотека jQuery.

Бібліотека - це набір корисних функцій, який розробляється одним програмістом або групою і викладається у вільний доступ для загального щастя.
Жодна бібліотека, і jQuery у т.ч., не є складовою джаваскрипта. Її розробляють окремі люди, і для того, щоб її використовувати, її необхідно підключити.
Бібліотека - не є якась особлива конструкція самої мови, це такі ж само функції і об"єкти, як і ті, що пишете ви. Ви просто берете і використовуєте їх.
Підключаються бібліотеки теж дуже просто, так само, як ви підключаєте свої файли із джаваскриптом до сторінки.
Наприклад, ось так виглядає підключення jQuery:
```
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
```
Вуаля, джквері готова до використання! Ви можете навіть зазирнути у вихідний код цієї бібліотеки(сорси), якщо хочете. Однак, це мініфікована версія, в якій буде нічого не зрозміло.
Отже, чим jQuery нам може допомогти?
Після підключення джквері нам стає доступна одна функція. Лише одна, зате яка! Функція називається $ (знак долара), і вона може майже все :)
```
$(".author").html("Megadeth");
```
Ось так, в одну строчку, ми знайшли потрібний нам тег(дів з класом author), і змінили його вміст(викликавши метод html)!
Давайте розберемося, як відбулося.
Спочатку ми викликали оту саму заповітну функцію $, і передали їй один аргумент.
Цей аргумент - строчка ".author". Функція $ виконує одну просту дію - вона шукає потрібний елемент у ДОМі, на основі переданого їй |селектора|.
Саме так, першим аргументом у функції $ є CSS селектор, за допомогою якого іде вибірка потрібного елемента.
Наприклад, вибрати той же самий вузол ми могли також і іншими способами:
```
$("body > div > div.author") // те саме, просто багатослівніше
$(".song > div:nth-child(2)") // той самий вузол
```
Отже, правило №1 jQuery:

|Робота з jQuery починається із виклика функції $, яка шукає потрібний елемент по переданому їй CSS селектору|

Потрібно розуміти, що код джаваскрипта на сторінці виконується послідовно, і ми не можемо звернутись до тих шматків хтмла, які ще не з"явились на сторінці.
Дуже розповсюджена помилка:
^
<script>
	// не буде працювати, на момент виконання коду
	// браузер ще не знає про існування вузла .enemy
	$(".enemy").css('background-color', 'red');
</script>
<div class="enemy">
	Wadding
</div>
^
<div class="enemy">
	Wadding
</div>
<script>
	// ok! 
	$(".enemy").css('background-color', 'red');
</script>
^
Отже, так само як ми не можемо виокристати змінну, яка оголошена пізніше, так само ми не можемо звернутись до ХТМЛа, який написаний пізніше.
Звідси витікає логічний висновок - писати більшість джаваскрипт кода в кінці сторінки, коли увесь ХТМЛ вже гарантован буде завантажений.
Тепер ви знаєте правило jQuery №2: 
|Коли робиш щось із вибраним елементом, переконайся, що він уже існує!|

# Методи jQuery

Але просто вибрати якийсь вузол - це невелике щастя, нам хочеться з ним щось зробити!
Ми можемо виконувати так дії із вибраним елементом:

а) змінити йому будь-який css-стиль або отримати поточне значення будь-якого його стилю

б) змінити його вміст або отримати його поточний вміст

в) перейти на сусідні елементи(батьківські, вкладені, сусідні)

г) навісити обробник подій на даний елемент

Перша за все скажу, що методів у Джквері багато, навіть дуже багато, і абсолютно усі їх мало хто знає.
Але як і у випадку з хтмл тегами, тут теж працює принцип Парето, коли на 20% методів припадає 80% роботи.
Ми зараз розберемо найбільш потрібні з них.

Спочатку стилі. Ви вже бачили вище приклад зміни стилю елемента:
```
$(".enemy").css('background-color', 'red');
```
Для цього є один-єдиний метод css(), який себе веде по-різному в залежності від обставин.
Якщо йому передати два параметри, перший буде означати ім"я цсс-стиля, а другий - значення, і це значення буде встановлене.
Якщо ж передати один параметр, то його значення буде повернуте.
```
// встановлюємо значення
$(".enemy").css('background-color', 'red');
var color = $(".enemy").css('background-color'); // отримуємо значення
console.log(color);// 'red'
console.log($(".enemy").css('display')); // 'block'
```
Також є розширений варіант, коли ми можемо передати цілу купу стилів за одним махом:
```
$("a").css({color: 'green', 'background-color': 'black'})
```
Ось такий гнучкий підхід робить використання jQuery легким і приємним.
Більшість із методів джквері мають кілька варіантів свого виконання в залежності від кількості і типу переданих аргументів.

Для деяких найбільш потрібних задач є спеціальні методи, наприклад:
```
$("a").width(300)	// встановлює ширину у 300 пікселів 
      .height(200)	// висоту у 200
      .hide();		// і приховує елемент(display: none)
```
# Ланцюжки методів(method chaining)

Стоп, а чому ви не питаєте, як так вийшло, що ми не обирали кожен раз елемент, а викликали кілька методів один за одним?
^
$("a").width(300);	
$("a").height(200);
$("a").hide();
^
$("a").width(300).height(200).hide();
^
Згадайте, що я писав на початку книжки. Грубо кажучи, усі функції можна розділити на два типи: функції, які обчислюють якесь значення і повертають його("чисті" функції)
і функції, які "щось роблять"("брудні" функції). Результат виконання чистих функцій записується у якісь змінні, інакше, вони не мають змісту.
```
var add_35 = function(a){ return a + 35;} // ось таке нехитре обчислення
var b = add_35(35); // 70, все ок
add_35(10); // безглуздий виклик функції, жодного сенсу в ньому нема
```
А те, що повертає брудна функція - не так і важливо, важливим у ній є такз званий "побічний ефект".
Ось наприклад, встановлення ширини для вузла - це брудна функція. Нам не дуже цікаво, що вона поверне, головне, що вона "щось зробить" у цей час.
У джквері більшість "брудних" методів(пишу в лапках, т.як строго кажучи, вони всі брудні) повертають той же самий об"єкт, над яким ми працювали.
```
var a = $("a");
a === a.width(300); // true
```
Так що ми можемо викликати кілька таких методів один за одним, поки на не набридне!
Однак, якщо ми зустрінемо метод, який повертає якесь значення, далі ланцюжок вже не вийде будувати.
^
$("ul > li").css("float", "left").height().hide();
// Так не пройде, метод height() без параметрів поверне поточне значення висоти,
// і далі викликати методи вже не вийде!
^
var height = $("ul > li").css("float", "left").height();
$("ul > li").hide();
^
Отже, правило jQuery №3:

|Ви можете викликати скільки завгодно методів у вибраного елемента один за одним, до тих пір, поки якийсь метод не поверне значення|

# Зміна вмісту елементу

Для цього є два основні методи: val() та html(). Перший використовується з тегами, які можуть містити введені юзером значення(input, select і т.д.), а другий - з усіма іншими тегами(div, a і т.д.).
^
<div class="form">
	<input type="text" name="nic" /> - enter your username.
</div>
<script>
	$(".form").val('ololo');// нічого не зміниться
	$("input[type=text]").html('Mikolalex');// так само нічого не зміниться
</script>
^
<div class="form">
	<input type="text" name="nic" /> - enter your username.
</div>
<script>
	$("input[type=text]").val('Mikolalex');// ok!
	$(".form").html('<div>Suddenly!</div>'); // інпут зникне, замість нього - div!
</script>
^
Ці методи, подібно до інших в джквері, мають два способи застосування:

а) якщо не передавати жодного аргумента - буде повернуте поточне значення

б) якщо передати аргумент, поточне значення буде замінене ним.
```
<div class="some-container">
	<ul>
		<li>1</li>
		<li>2</li>
		<li>3</li>
	</ul>
</div> 
<script>
	var selector = ".some-container";
	$(selector).html(); /*
		Поверне:
		<ul>
			<li>1</li>
			<li>2</li>
			<li>3</li>
		</ul>	
	*/
	$(selector).html('<ul>' + 
			'<li>1</li>' +
			'<li>2</li>' +
			'<li>3</li>' +
			'<li>4</li>' +
		'</ul>').css('border-color', 'red');
	// замінить старий ul новим і змінить стиль
</script>
```
```
Choose your gender:
<select>
	<option value="1">Male</option>
	<option value="2" selected>Female</option>
	<option value="3">Other</option>
</select>
<script>
	$("select").val(); // 2
	$("select").val(3); // елемент з value="3" стає вибраним
	$("select").val(); // 3
</script>
```?
Звертаю увагу, що методи html() і val() |повністю| замінюють старий вміст елемента новим.
Якщо ж нам треба дописати щось нове до існуючого контенту, треба скористатись методом append()(або prepend(), щоб додати в початок)

Також існує метод text(), який буде замінювати спецсимволи на їх HTML-коди, екрануючи, таким чином, хтмл.
```
<div class="ex-1">
	<div style="background-color: red;height:20px;">RED</div>
</div>
<div class="ex-2">
	<div style="background-color: red;height:20px;">RED</div>
</div>
<div class="ex-3">
	<div style="background-color: red;height:20px;">RED</div>
</div>
<div class="ex-4">
	<div style="background-color: red;height:20px;">RED</div>
</div>
<script>
	var str = '<div style="background-color: grey;height:20px;">GREY</div>';
	$(".ex-1").html(str);
	$(".ex-2").text(str);
	$(".ex-3").append(str);
	$(".ex-4").prepend(str);
</script>
```
# Події
Ось нарешті ми дійшли до цього! Освоївши обробку подій за допомогою джквері, ви зможете написати свій перший не-такий-вже-й-безглуздий скрипт!
Отже, про як події іде мова?
Згадайте, на початку ми говорили про різницю між ХТМЛом і джаваскриптом. Найсуттєвіша відмінність полягає в тому, що джаваскрипт, напротивагу повністю
статичному ХТМЛу, працює динамічно і забезпечує створення інтерактивності на сторінці. 
Порівняємо:
ХТМЛ: один раз завантажився, і показується у своєму незмінному вигляді(тепер ви знаєте, що ХТМЛ можна змінювати, але ж це робить джаваскрипт, а не сам ХТМЛ!)
Джаваскрипт: завантажився, і працює! Реагує на дії юзера!
Дотепер ми уміли робити тільки якісь, грубо кажучи, підрахунки: складати числа і строчки, створювати об"єкти і масиви, робили це все гуртом(циклами) і вроздріб.
Але ж інтерактивність, де вона? - спитаєте ви, - як вона здійснюється в джаваскрипті? 

Інтерактивність зроблена так: ми прописуємо в джаваскрипті, як реагувати на дії юзера.
Наприклад, "якщо юзер клікнув по одному з елементів меню, відкрити попап і показати в ньому такий-то контент".
І далі: "якщо попап відкритий, то при кліку на хрестик ми закриваємо попап. Також ми закриваємо попап, ящко юзер клікне на поле поза ним".
На джквері це виглядало б приблизно так:
```
// ця функція відповідає за показ попапа
var show_popup = function(){
    var header = 'Hello, Im stupid popup!',
        content = 'Lorem ipsum';
    $(".some-popup-container")
        .show() // = css('display', 'block')
        .html('<h2>' 
            + header + 
        '</h2><div class="popup_text">' 
            + content + 
        '</div><div class="close">Close</div>');
}
// функція для закриття попапа - просто очищує вузол, де лежить попап.
var hide_popup = function(){
    $(".some-popup-container").html("").hide();
}
$("menu > li.a").click(show_popup); // по кліку - показати попап!
(=запустити функцію, яка його показує)
$(".some-popup-container .close").click(hide_popup); 
// якщо юзер клікає по кнопці "Close", то закрити попап!
```
Досить просто і зрозуміло, чи не так? (щоправда, цей код не буде працювати, що, однак, не відміняє його простоти і вишуканості).
Кожна подія має дві складові: тип і об"єкт. Наприклад, "клік по пункту меню" - тут тип буде "клік", а об"єкт - елементи ДОМ, вибрані по селектору "menu > li".

Типів івентів існує багато, однак, тут теж працює принцип 80/20: в більшості випадків використовуються одні й ті самі базові івенти.
Це, звичайно, клік (click), також є івент "mouseover", який спрацьовує, коли юзер просто наводить мишку на об"єкт.
Для елементів форм є івенти focus(юзер поставив курсор на текстовий інпут) і blur (юзер покинув дане поле і перейшов до іншого).
Є ще і інші івенти, але для початку нам вистачить одного, найбільш основного - клік.

Щодо об"єкту івенту, себто, "до чого цей івент був застосований", то тут все просто. Об"єкт - це елемент ДОМ дерева, тобто, якийсь тег.

Те, що ми зробили у прикладі коду вище, називається на професійному жаргоні так: "ми навісили хендлери на івенти".
Це значить, ми призначили функції(хендлери, handlers), які виконаються в разі, якщо відбудеться якась подія(event).
Із джквері це робиться так: ми обираємо якийсь елемент, (у прикладі ми обрали $("menu > li.a")), 
і показуємо, що робити, якщо по ньому клікнуть( .click(show_popup)).
На кожен івент у джквері є своя функція: .click() щоб навісити хендлер для події "клік", .mouseover(), .blur(), .focus() і т.д. для відповідних подій.

Можливо, більш логічно було б назвати цю функцію не click(), а add_handler_on_user_click(), однак для лаконічності її назвали просто click().
Аргументом для функцій-івентів є функції! Ви ж вже знаєте, що в джаваскрипті ми можемо передавати і повертати функції, як нам заманеться.
Ось тепер ми можемо прочитати дану строчку:
```
$(".some-popup-container").click(hide_popup); 
```
Так: "якщо юзер клікне по елементу, який обраний селектором ".some-popup-container", то виконати функцію hide_popup().

Тепер давайте подумаємо над дуже важливим питанням. Коли і скільки разів буде виконана функція show_popup()?
Подивимось на цей приклад під іншим кутом:
```
var show_popup = function(){
    console.log('A');
    // doing some real work, bla-bla-bla...
}
$("menu > li.a").click(show_popup);
console.log('B');
```
Що буде перше виведене в консоль, А чи Б? Звісно, спочатку Б, а потім А!
Чому?
Коли ми пишемо
```
$("menu > li.a").click(show_popup);
```
в цей момент функція show_popup не викликається! Ми лише наказуємо джаваскрипту: 
"якщо станеться така-то подія, викличи цю функцію!", але НЕ виконуємо її!
Тобто, функція show_popup може і... взагалі ніколи не виконатися!
Тепер повернімося до нашого прикладу ще раз:
```
var show_popup = function(){
    var header = 'Hello, Im stupid popap!',
        content = 'Lorem ipsum';
    $(".some-popup-container")
        .show() // = css('display', 'block')
        .html('<h2>' 
            + header + 
        '</h2><div class="popup_text">' 
            + content + 
        '</div><div class="close">Close</div>');
}

var hide_popup = function(){
    $(".some-popup-container").html("").hide();
}

$("menu > li.a").click(show_popup);
$(".some-popup-container .close").click(hide_popup);
```
В чому тут помилка? Ми порушили друге правило jQuery! Ми намагаємось навісити хендлер на елемент .some-popup-container .close, якого на цей момент ще не існує!
Він з"явиться лише після того, як виконається функція show_popup і згенерує ось цей елемент .close!
Тому, доведеться дещо переписати наш приклад. Тепер ми будемо навішувати хендлер на елемент тільки тоді, коли він вже буде існувати у ДОМі!
```
var hide_popup = function(){
    $(".some-popup-container").html("").hide();
}

var show_popup = function(){
    var header = 'Hello, Im stupid popup!',
        content = 'Lorem ipsum';
    $(".some-popup-container")
        .show() // = css('display', 'block')
        .html('<h2>' 
            + header + 
        '</h2><div class="popup_text">' 
            + content + 
        '</div><div class="close">Close</div>');
    // навішуємо хендлер ПІСЛЯ того, як ми вставили елемент!
    $(".some-popup-container .close").click(hide_popup);
}

$("menu > li.a").click(show_popup);
```
Це вже "дещо" краще!
Давайте трохи ускладнимо наш приклад. Якщо попап відкритий, і юзер ще раз клікає по його імені у списку меню, то нехай попап закривається!
```
$("menu > li.a").click(/*
    Якщо попап ще не відкритий, то відкрити його.
    Якщо вже відкритий, то закрити.
*/)
```
Як нам це зробити? Можна ввести додаткову змінну, "прапорець", яка буде містити інформацію, відкритий зараз попап чи ні.
Також в якості аргумента для функції click() ми можемо передати анонімну функцію!
```
// ось ця змінна, яка нам каже, відкритий попап чи ні.
var popup_opened = false;

var hide_popup = function(){
    $(".some-popup-container").html("").hide();
    // оновлюємо стан!
    popup_opened = false;
}

var show_popup = function(){
    var header = 'Hello, Im stupid popup!',
        content = 'Lorem ipsum';
    $(".some-popup-container")
        .show() // = css('display', 'block')
        .html('<h2>' 
            + header + 
        '</h2><div class="popup_text">' 
            + content + 
        '</div><div class="close">Close</div>');
    $(".some-popup-container .close").click(hide_popup);
    // оновлюємо стан і тут теж!
    popup_opened = true;
}

$("menu > li.a").click(function(){
    if(popup_opened){
        hide_popup();
    } else {
        show_popup();
    }
});
```

Далі ми будемо розбирати і практикувати джквері на прикладі.

@@@
@@@
## jQuery на практиці: стрічка коментарів
Почнемо поглиблювтаи наші знання джквері, виконуючи практичні завдання, ціклмо близько до реальних бойових умов!
Зараз ми зробимо стрічку коментарів. Коментарі можна додавати, і вони будуть з"являтись у стрічці одразу, без перезавантаження сторінки.
Також юзер може редагувати і видаляти власні коментарі. 

Ми зробимо це в дещо спрощеному вигляді, а далі будемо нарощувати функціонал, щоб максимально наблизитись до реальних застосунків.
Паралельно ми будемо працювати над якістю коду: почнемо із наївно-інтуїтивного підходу, а, осмисливши те, що у нас вийшло, перепишемо код у
більш приємній формі.

Отже, спочатку ТЗ: кожен коментар має автора, текст і дату. Коментарі виводяться згори вниз від старіших до новіших.
Структура коментарів лінійна(тобто не деревовидна ;). Внизу під коментарями виводиться форма для додавання нового коментаря.
При додаванні нового коментаря ми перевіряємо, щоб усі поля були заповнені(ім"я автора і текст). Дата виставляється автоматично.
Якщо все ок, ми додаємо коментар у список, і очищуємо форму для додавання. Коментарі самого юзера повинні мати лінки: "Видалити" і "Редагувати"
При кліку на "Видалити" коментар зникає, при кліку на "Редагувати" текст коментаря і ім"я автора попадають в форму(т.як наче юзер це ввів сам),
юзер може редагувати їх, після відправки форми коментар оновлюється введеним.

Умовність даного прикладу в тому, що справжня стрічка коментарів буде, перш за все, отримувати список існуючих коментів із сервера,
і відправляти туди ж новододані коментарі, так щоб усі юзери бачили одне й те саме :) Спілкування із сервером на джаваскрипті реалізується
за допомогою технологій, відомих як AJAX, і ми обов"язково роздивимось їх після того, як зробимо основну частину цієї задачі.

# Як це реалізовувати

Перш ніж почати писати, треба прикинути, як це буде виглядати в цілому. Пропоную застосувати підхід, який полягає на відокремленні даних(model) 
від їх графічного представлення в хтмлі(view). Це, насправді, дуже просто і інтуїтивно зрозуміло.
Спочатку ми повинні продумати, як буде відбуватись робота і маніпуляція даними, а потім напишемо, як відображати ці зміни графічно.

# Розробка моделі

Спочатку, як виглядатимуть наші дані - це буде масив із об"єктами, які позначатимуть конкретні коменти. Такі масиви називають також колекціями.
Отже, у нас є колекція коментарів:
```
var comments = [
    {
        user: 'Vova',
        text: 'Nice photo!',
        date: '2001-01-01 10:00:01'
    },
    {
        user: 'Petya',
        text: '+1',
        date: '2001-01-02 11:24:01'
    },
    ...
]
```
Начебто, все просто. А як ми будемо додавати, редагувати, видаляти коменти? Потрібно написати функції(або методи) для цього.
Поки що лише продумаємо їх інтерфейс.
```
// додати новий комент можна за допомогою стандартного методу масива - push
comments.push({user: 'Joe', text: 'Cool!'});
/*
Щоб отримати текст коментаря, треба знати його номер - індекс у масиві.
Для цього ми напишемо метод для колекції comments!
*/
comments.get = function(ind){ ... };
// Приклад: отримуємо другого юзера(індекс 1)
comments.get(1); // {user: 'Petya', text: '+1', date: '2001-01-02 11:24:01'}

/*
Має бути також функція update(ind, values) яка оновить існуючий коментар після редагування.
*/
comments.update = function(ind, values){ ... }
comments.update(0, {text: 'VERY nice photo!'});// ok
comments.get(0); // { user: 'Vova', text: 'VERY nice photo!', date: '2001-01-01 10:00:01'}
// як бачимо, поле text змінилося, інші поля залишились, як і були

// і тепер зовсім просто - функція для видалення
comments.remove = function(i){ ... };

comments.remove(1);
comments.get(1); // undefined
```

# Розробка view

Тепер нам треба:

а) написати функцію для генерації ХТМЛа із списком коментарів.
б) призначити обробники подій, які дозволять нам реагувати на дії юзера і спричинятимуть додавання коментаря, його редагування і т.п.

Тут можна використати деякі наші давні напрацювання :)
Наприклад, який у нас буде ХТМЛ конкретного коментаря? Думаю, його можна(і треба) зробити максимально простим!
Крім цього, треба передбачити кнопку "видалити" і "змінити".
```
<div class="comment">
    <div class="user">
        Mike
    </div>
    <div class="text">
        Awesome!
    </div>
    <div class="date">
        2011-01-01 14:30:01
    </div>
    <div class="edit">
        Редагувати
    </div>
    <div class="delete">
        Видалити
    </div>
</div>
```
Реалізація такої функції буде тривіальною:
```
var get_comment_html = function(comment){
    return '<div class="comment">' +
    '<div class="user">' +
        comment.user
    '</div>' +
    '<div class="text">' +
        comment.text
    '</div>' +
    '<div class="date">' +
        comment.date
    '</div>' +
    '<div class="edit">' +
        'Редагувати'
    '</div>' +
    '<div class="delete">' +
        'Видалити'
    '</div>' +
'</div>';
}
```
Виглядає не дуже, але незай поки буде так, далі ми навчимось, як за допомогою шаблонів робити
такі речі простішими і приємнішими.
Функція генерації ХТМЛ-кода усього списку коментарів повинна викликати для кожного коментаря
get_comment_html(), складати результати воєдино і повертати їх.

Тепер до обробників подій.
Перша подія, на яку нам треба зреагувати - це завантаження сторінки :) Коли вона завантажиться,
ми повинні вивести список коментарів. У jquery є дуже простий спосіб призначити функцію, яка спрацює після завантаження сторінки:
^
<script>
    console.log($(".cont").html());
    // пусто, т.як на момент виконання цього коду 
    // браузер ще не знає про існування тега .cont нижче
</script>
<div class="cont">
    Hello!
</div>
^
<script>
    var do_something = function(){
        console.log($(".cont").html());
    }
    $(document).ready(do_something);
    // Все ок, функція do_something буде виконана після загрузки усього ХТМЛа, у т.ч .cont
    // Для цього є навіть коротший запис:
    $(do_something); // те саме, що і $(document).ready(do_something)
</script>
<div class="cont">
    Hello!
</div>
^
Конструкція виду $(function(){ ... }) в jQuery дозволяє нам виконувати потрібний код після того, як уся сторінка гарантовано завантажилась.

Отже, ми повинні реагувати на такі події:

а) завантаження сторінки - виводимо список коментарів

б) додавання нового коментаря(а саме клік по кнопці "Додати") - додаємо новий комент у модель, виводимо список коментарів

в) видалення коментаря(клік по кнопці "видалити" на коментарі) - видаляємо комент із моделі, виводимо список коментарів

г) клік по кнопці редагувати - заповнюємо форму даними із коментаря, після відправки цієї форми змінюємо текст вибраного коментаря, виводимо список коментів.

Схематично це виглядатиме так:
```
// функція для виведення списку коментарів
var generate_comments_list = function(){ ... };
// функція, яка збирає дані із форми і повертає новий об"єкт із цими даними(коментар)
var add_comment = function(){ ... };
// функція, яка видаляє даний коментар
var delete_comment = function(){ ... };
// функція, яка заповнює форму внизу поточним коментарем для редагування:
var fill_form_with_comment = function(){ ... };
// функція, яка редагує комент по переданому номеру
var edit_comment = function(num){ ... };

// а)
$(generate_comments_list);

// б)
$(".add-comment").click(function(){
    add_comment();
    generate_comments_list();
});

// в)
$(".delete").click(function(){
    delete_comment();
    generate_comments_list();
})

// г)
$(".edit").click(function(){
    fill_form_with_comment();
})

```
Як бачите, більшість функцій із нашого view буде брудними. Це значить, що ці функції нічого не приймають і нічого не повертають в результаті свого виконання,
а весь сенс цих функцій полягає у т.зв. побічному ефекті - змінах загального стану, наприклад, модифікація ДОМ.
Якщо ми трохи подуумаємо, то побачимо, що тут виникає проблема! При редагуванні, ми заповнюємо форму внизу даними із коментаря, і кнопка "додати коментар" має працювати по іншому
 - замість того, щоб додавати новий коментар, вона повинна оновлювати той, який редагується в даний момент!
Нам треба переписати деякі функції, щоб вони працювали правильно. Використаємо змінну-"прапорець", яка буде індикатором, що нам робити по кліку:
додавати новий комент чи редагувати існуючий, і який саме.
Перепишемо ще раз:
```
// ось ця змінна-індикатор
var active_comment = false;

$(generate_comments_list);

$(".add-comment").click(function(){
    // якщо активного коментаря(коментар, який зараз редагується) нема, то додаємо новий
    if(!active_comment){
        add_comment();
        generate_comments_list();
    } else {
    // інакше, оновлюємо існуючий коментар
        edit_comment(active_comment);
        active_comment = false;
        // !!! важливо! Після того, як редагування завершено,
        // повертаємо змінну у початковий стан!
    }
    clear_form();
    // в будь-якому разі, очищуємо форму після використання
});

$(".delete").click(function(){
    delete_comment();
    generate_comments_list();
})

// г)
$(".edit").click(function(){
    active_comment = get_current_comment_id();// умовна функція
    fill_form_with_comment();
})
```
Ну що, вітаю, наш аплікейшн вже практично готовий, залишилось лише написати реалізацію деяких функцій! :)
Ми застосували підхід, коли ми спочатку наперед продумуємо структуру нашого аплікейшна, а потім вже - деталі.
Для кожної функції ми продумуємо інтерфейс. Інтерфейс функції - це те, що вона приймає(які аргументи), і що вона повертає.
Однак, звичайно ж ми не можемо продумати усе наперед! Звісно, під час реалізації задуманого виникне кілька проблем.
Все наперед продумати неможливо, але треба старатись, щоб архітектура вашого аплікешйна була досить гнучкою.
Що розуміється під гнучкістю - зрозумієте трохи пізніше :)

# Реалізація

Це вже діло техніки) Подивіться на функції моделі. Це прості маніпуляції з об"єктами і масивами. Вони реалізовані
як методи, тобто, є якийсь об"єкт, до якого належить дана функція і він буде доступний через змінну this.
Почнемо:
```
var list = [{name: 'John'}, {name: 'Carl'}, {name: 'Iohann'}];
//list.get(1); // {name: 'Carl'}
???5%list.get(2).name === 'Iohann'%
list.get = function(i){
    // звернутись до масиву list ми можемо через змінну this! Т.як ми викликаємо 
    // функцію get як метод list'а
    return this[i];
}
%

```
```
var list = [{name: 'John'}, {name: 'Carl'}, {name: 'Iohann'}];
// list.update(1, {name: 'Ivan', surname: 'Ryabchych'});
// list.get(1); // {name: 'Ivan', surname: 'Ryabchych'}
// змінюємо прізвище
// list.update(1, {surname: 'Gusev'});
// list.get(1); // {name: 'Ivan', surname: 'Gusev'}
???5%(list.update(2, {surname: 'Hanssen'}) !== false) && (list[2].name === 'Iohann') && (list[2].surname === 'Hanssen')%
list.update = function(ind, new_vals){
    console.log(arguments);
    for(var i in new_vals){
        this[ind][i] = new_vals[i];
    }
}
%

```
```
var list = [{name: 'John'}, {name: 'Carl'}, {name: 'Iohann'}];
// list.remove(1);
// list.get(1); // undefined
???4%(list.remove(2) !== false) && list[2] === undefined%
    list.remove = function(i){
        delete this[i];
    }
%
```
@@@